<!DOCTYPE html>
<!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
<html lang="vi-VN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quy Khư - Túc Mệnh Luân Hồi</title>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */
      @import url('?family=ZCOOL+KuaiLe&family=Ma+Shan+Zheng&display=swap');

      /* --- 基础与布局 --- */
      .guixu-root-container {
        font-family: 'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        color: #c9aa71;
        border: 1px solid #c9aa71;
        border-radius: 8px;
        overflow: hidden;
        max-width: 100%;
        margin: auto;
        box-shadow: 0 0 15px rgba(201, 170, 113, 0.2);
        position: relative;
        width: 100%;
        /* aspect-ratio: 16 / 9; */ /* 移除宽高比，使用固定高度 */
        //max-width: 900px; /* 恢复原始宽度 */
      }

      .guixu-root-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 15, 35, 0.7);
        z-index: 1;
      }

      .game-container {
        position: relative;
        z-index: 2;
        display: grid;
        grid-template-rows: 65px 1fr auto; /* 让底部栏高度自适应 */
        grid-template-columns: 220px 1fr 160px;
        width: 100%;
        gap: 1px;
        height: 600px; /* 固定高度以便滚动 */
      }

      .guixu-root-container * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

		/* THÊM MỚI 2 loại: Điều chỉnh layout khi ở chế độ toàn màn hình */
	  .guixu-root-container:fullscreen {
	    max-width: none; /* Bỏ giới hạn chiều rộng khi toàn màn hình */
	    height: 100%; /* Chiếm toàn bộ chiều cao */
	    border-radius: 0; /* Bỏ bo góc */
	    border: none; /* Bỏ viền */
	  }
	  .guixu-root-container:fullscreen .game-container {
  	    height: 100%; /* Quan trọng: Cho phép container game giãn ra 100% chiều cao của cha nó */
  	  }	  

      /* --- 各面板样式 --- */
      .top-status {
        grid-column: 1 / -1;
        background: linear-gradient(
          90deg,
          rgba(26, 26, 46, 0.8) 0%,
          rgba(45, 27, 61, 0.8) 50%,
          rgba(26, 26, 46, 0.8) 100%
        );
        border-bottom: 1px solid #c9aa71;
        display: flex;
        align-items: center;
        justify-content: space-around;
        padding: 0 10px;
        box-shadow: 0 1px 8px rgba(201, 170, 113, 0.15);
      }
      .status-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      .status-label {
        font-size: 11px;
        color: #8b7355;
      }
      .status-value {
        font-size: 14px;
        color: #c9aa71;
        font-weight: bold;
      }
      .progress-bar {
        width: 70px;
        height: 5px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 3px;
        overflow: hidden;
        border: 1px solid #c9aa71;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff6b6b, #ffd93d);
        border-radius: 2px;
      }
      .guixu-charge {
        width: 100px;
        height: 6px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 4px;
        border: 1px solid #8b4513;
        overflow: hidden;
      }
      .guixu-fill {
        height: 100%;
        background: linear-gradient(90deg, #dc143c, #ff6b6b, #ffd700);
        width: var(--guixu-charge, 0%);
        border-radius: 3px;
      }

      .character-panel {
        background: rgba(26, 26, 46, 0.5);
        border-right: 1px solid #c9aa71;
        padding: 10px;
        overflow-y: auto;
      }
      .panel-section {
        margin-bottom: 15px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        border: 1px solid rgba(201, 170, 113, 0.3);
      }
      .section-title {
        font-size: 13px;
        color: #c9aa71;
        margin-bottom: 8px;
        text-align: center;
        border-bottom: 1px solid rgba(201, 170, 113, 0.3);
        padding-bottom: 4px;
      }
      .equipment-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }
      .equipment-slot {
        aspect-ratio: 1;
        background: rgba(0, 0, 0, 0.5);
        border: 1px dashed rgba(201, 170, 113, 0.5);
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: #8b7355;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      .equipment-slot.equipped {
        border-style: solid;
        color: #e0dcd1;
        font-size: 12px;
      }
      .equipment-slot:hover {
        background: rgba(201, 170, 113, 0.1);
      }
      .attributes-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .details-container {
        margin-bottom: 5px;
      }
      .details-container summary {
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        list-style: none; /* 隐藏默认箭头 */
      }
      .details-container summary::-webkit-details-marker {
        display: none; /* 隐藏默认箭头 */
      }
      .details-content {
        padding: 8px;
        margin-top: 4px;
        font-size: 11px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        border-top: 1px solid rgba(201, 170, 113, 0.2);
        color: #a09c91;
      }
      .details-content p {
        margin-bottom: 4px;
      }
      .attribute-item {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
      }
      .attribute-name {
        color: #8b7355;
      }
      .attribute-value {
        color: #c9aa71;
        font-weight: bold;
      }

      .interaction-panel {
        background: rgba(45, 27, 61, 0.5);
        border-left: 1px solid #c9aa71;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto; /* 新增：允许交互面板在内容过多时滚动 */
      }
      .interaction-btn {
        padding: 10px 8px;
        background: linear-gradient(45deg, #1a1a2e, #2d1b3d);
        border: 1px solid #c9aa71;
        border-radius: 5px;
        color: #c9aa71;
        font-size: 12px;
        cursor: pointer;
        text-align: center;
        transition: all 0.3s ease;
      }
      .interaction-btn:hover {
        background: linear-gradient(45deg, #2d1b3d, #3d2b4d);
      }
      .world-line-section {
        border-top: 1px solid rgba(201, 170, 113, 0.5);
        padding-top: 10px;
        margin-top: auto;
      }
	  /* THÊM MỚI */
      .world-line-section > div {
        flex-direction: column;
      }
      .world-line-title {
        font-size: 10px;
        color: #8b7355;
        text-align: center;
        margin-bottom: 6px;
      }
      .primary-btn {
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border-color: #daa520;
        color: #fff;
      }
      .auto-write-section {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 15px; /* 与上方内容隔开 */
        padding-top: 15px; /* 与上方内容隔开 */
        border-top: 1px solid rgba(201, 170, 113, 0.3); /* 分割线 */
      }
      .auto-write-label {
        font-size: 12px;
        color: #8b7355;
        cursor: pointer;
      }
      #auto-write-checkbox {
        cursor: pointer;
      }
      .primary-btn:hover {
        background: linear-gradient(45deg, #cd853f, #daa520);
      }

      .bottom-status {
        grid-column: 1 / -1;
        background: linear-gradient(
          90deg,
          rgba(45, 27, 61, 0.8) 0%,
          rgba(26, 26, 46, 0.8) 50%,
          rgba(45, 27, 61, 0.8) 100%
        );
        border-top: 1px solid #c9aa71;
        display: flex;
        align-items: center;
        justify-content: space-between; /* 修改对齐方式 */
        gap: 15px; /* 增加间距 */
        padding: 0 15px;
        transition: height 0.2s ease-in-out; /* 新增：高度变化动画 */
      }
      .quick-send-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .quick-send-input {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #8b7355;
        border-radius: 4px;
        color: #e0dcd1;
        padding: 5px 10px;
        font-size: 12px;
        width: 250px; /* 给一个初始宽度 */
        height: 32px; /* 与按钮高度对齐 */
        resize: none; /* 禁止用户调整大小 */
        line-height: 1.5; /* 调整行高使单行文本看起来居中 */
        font-family: inherit; /* 继承字体 */
        overflow-y: auto; /* 内容超出时显示滚动条 */
        transition: height 0.2s ease-in-out;
      }
      .quick-send-input:focus {
        height: 80px;
      }
      .quick-send-input::placeholder {
        color: #8b7355;
      }

      /* --- 新增：快速指令弹出菜单 --- */
      #quick-command-popup {
        display: none;
        position: absolute;
        bottom: 65px; /* 增加bottom值，将菜单上移 */
        right: 175px; /* 大致对齐到快速发送区域 */
        background: rgba(15, 15, 35, 0.98);
        border: 1px solid #c9aa71;
        border-radius: 6px;
        z-index: 1002;
        width: 280px;
        max-height: 200px;
        overflow-y: auto;
        box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.5);
      }
      .quick-command-list {
        list-style: none;
        padding: 5px;
        margin: 0;
      }
      .quick-command-item {
        padding: 8px 12px;
        color: #a09c91;
        font-size: 12px;
        /* cursor: pointer; */ /* 移除指针手势 */
        border-bottom: 1px solid rgba(201, 170, 113, 0.1);
        transition: background-color 0.2s;
      }
      .quick-command-item:last-child {
        border-bottom: none;
      }
      .quick-command-item:hover {
        background-color: rgba(201, 170, 113, 0.15);
        color: #e0dcd1;
      }
      .quick-command-empty {
        padding: 15px;
        text-align: center;
        color: #8b7355;
        font-style: italic;
        font-size: 12px;
      }

      .status-effect {
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 4px 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        border: 1px solid rgba(201, 170, 113, 0.3);
        white-space: nowrap;
        font-size: 10px;
      }
      .effect-icon {
        width: 14px;
        height: 14px;
        background: #c9aa71;
        border-radius: 50%;
      }

      /* --- 中央内容区 --- */
      .main-content {
        padding: 20px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.2);
      }
      .game-text-container {
        font-size: 14px;
        line-height: 1.8;
        color: #e0dcd1;
        white-space: pre-wrap;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      }

      /* --- 新增：正文染色样式 --- */
      .text-language {
        color: #ff1493; /* 荧光粉色 */
        font-style: italic;
      }
      .text-psychology {
        color: rgba(255, 255, 255, 0.7); /* 半透明白色 */
        font-style: italic;
      }
      .text-scenery {
        color: #98fb98; /* 淡绿色 */
      }

      /* --- 模态窗口 (Modal) 样式 --- */
      .modal-overlay {
        display: none; /* 默认隐藏 */
        position: absolute; /* 相对于 .guixu-root-container 定位 */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .modal-content {
        background: rgba(26, 26, 46, 0.95);
        border: 1px solid #c9aa71;
        border-radius: 8px;
        padding: 20px;
        width: 90%;
        max-width: 800px;
        height: 90%;
        max-height: 550px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 0 20px rgba(201, 170, 113, 0.3);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(201, 170, 113, 0.5);
        padding-bottom: 10px;
        margin-bottom: 15px;
      }
      .modal-title {
        font-size: 18px;
        color: #c9aa71;
      }
      .modal-close-btn {
        font-size: 24px;
        color: #8b7355;
        cursor: pointer;
        background: none;
        border: none;
      }
      .modal-close-btn:hover {
        color: #c9aa71;
      }
      .modal-body {
        flex-grow: 1;
        overflow-y: auto;
      }

      /* --- 大事记时间线样式 (参考 修仙之路) --- */
      .timeline-container {
        position: relative;
        padding: 20px 0;
        margin-left: 20px;
      }
      .timeline-line {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #e0e0e0; /* 改为浅灰色 */
      }
      .timeline-event {
        position: relative;
        margin-bottom: 30px;
        padding-left: 30px;
        transition: all 0.3s ease;
      }
      .timeline-event:hover {
        transform: translateX(5px);
      }
      .timeline-event::before {
        content: '';
        position: absolute;
        left: -5px;
        top: 5px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #ffffff; /* 改为白色 */
        border: 2px solid #cccccc; /* 改为灰色边框 */
      }
      .timeline-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .timeline-date {
        font-size: 12px;
        color: #757575; /* 深灰色 */
        font-style: italic;
      }
      .timeline-tags {
        display: flex;
        gap: 5px;
      }
      .tag-item {
        background-color: #eeeeee; /* 浅灰色背景 */
        border: 1px solid #e0e0e0;
        color: #616161; /* 深灰色文字 */
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        font-style: italic;
      }
      .timeline-content {
        background: #ffffff; /* 改为白色背景 */
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #000000; /* 黑色边框 */
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .timeline-title {
        font-weight: bold;
        margin-bottom: 8px;
        color: #212121; /* 近黑色 */
        font-style: italic;
      }
      .timeline-description {
        font-size: 13px;
        color: #424242; /* 深灰色 */
        line-height: 1.7;
      }

      .past-life-details {
        margin-top: 10px;
        font-size: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        color: #424242; /* 深灰色 */
      }

      .detail-item > strong {
        color: #212121; /* 近黑色 */
        margin-right: 5px;
        font-style: italic;
      }

      /* 滚动条 */
      ::-webkit-scrollbar {
        width: 5px;
      }
      /* ::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
      } */ /* 暂时注释掉以避免SillyTavern核心脚本错误 */
      ::-webkit-scrollbar-thumb {
        background: rgba(201, 170, 113, 0.5);
        border-radius: 3px;
      }

      /* --- 背包模态框样式 --- */
      .inventory-category {
        margin-bottom: 15px;
        border: 1px solid rgba(201, 170, 113, 0.3);
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }
      .inventory-category-title {
        padding: 10px 15px;
        font-size: 16px;
        color: #c9aa71;
        cursor: pointer;
        list-style: none; 
        display: block;
        background: rgba(0, 0, 0, 0.3);
      }
      .inventory-category-title::-webkit-details-marker {
        display: none; 
      }
      .inventory-item-list {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .inventory-item {
        background: rgba(26, 26, 46, 0.7);
        border: 1px solid rgba(201, 170, 113, 0.2);
        border-radius: 4px;
        padding: 10px;
      }
      .item-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start; /* 改为顶部对齐 */
        margin-bottom: 8px;
      }
      .item-details {
        margin-top: 10px;
        font-size: 12px;
        border-top: 1px solid rgba(201, 170, 113, 0.2);
        padding-top: 8px;
      }
      .item-name {
        font-weight: bold;
        color: #e0dcd1;
      }
      .item-quantity {
        font-size: 12px;
        color: #8b7355;
      }
      .item-description {
        font-size: 12px;
        color: #a09c91;
      }
      .empty-category-text {
        color: #8b7355;
        font-style: italic;
        padding: 10px;
        text-align: center;
      }

      /* --- 装备按钮和悬浮提示框 --- */
      .item-equip-btn,
      .item-unequip-btn {
        padding: 4px 10px;
        font-size: 12px;
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border: 1px solid #daa520;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
        margin-left: 15px;
      }
      .item-equip-btn:hover,
      .item-unequip-btn:hover {
        background: linear-gradient(45deg, #cd853f, #daa520);
      }
      .item-use-btn {
        padding: 4px 10px;
        font-size: 12px;
        background: linear-gradient(45deg, #8b4513, #cd853f);
        border: 1px solid #daa520;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
        margin-left: 15px;
      }
      .item-use-btn:hover {
        background: linear-gradient(45deg, #cd853f, #daa520);
      }
      .item-discard-btn {
        padding: 4px 10px;
        font-size: 12px;
        background: #8b0000;
        border: 1px solid #ff6b6b;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
        margin-left: 5px;
      }
      .item-discard-btn:hover {
        background: #a52a2a;
      }
      #equipment-tooltip {
        display: none;
        position: absolute; /* 跟随鼠标 */
        background: rgba(15, 15, 35, 0.95);
        border: 1px solid #c9aa71;
        border-radius: 6px;
        padding: 15px;
        color: #e0dcd1;
        font-size: 12px;
        z-index: 1001;
        width: auto;
        max-width: 300px;
        pointer-events: none;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      }
      .tooltip-title {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(201, 170, 113, 0.4);
      }
      .tooltip-section {
        margin-top: 10px;
      }
      .tooltip-section-title {
        color: #8b7355;
        font-style: italic;
        margin-bottom: 5px;
      }
      .tooltip-attributes p {
        margin: 3px 0;
      }
      .tooltip-attributes strong {
        color: #c9aa71;
        margin-right: 5px;
      }

      .command-center-actions {
        list-style-type: none;
        padding: 0;
        margin-bottom: 20px;
      }
      .command-center-action-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 8px;
        font-size: 14px;
      }
      .command-center-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-top: auto; /* 推到底部 */
        padding-top: 15px;
        border-top: 1px solid rgba(201, 170, 113, 0.5);
      }

      /* --- 角色详情模态框美化 --- */
      #character-details-modal .modal-content {
        background: radial-gradient(circle, rgba(45, 27, 61, 0.9) 0%, rgba(15, 15, 35, 0.95) 100%);
        border: 1px solid #8b7355;
        box-shadow: 0 0 25px rgba(201, 170, 113, 0.3);
      }

      #character-details-modal .section-title {
        font-family: 'Ma Shan Zheng', cursive;
        font-size: 16px;
        letter-spacing: 1px;
      }

      #character-details-modal .attributes-list {
        gap: 0; /* 移除gap，使用边框分隔 */
      }

      #character-details-modal .attribute-item {
        padding: 8px 4px;
        border-bottom: 1px solid rgba(201, 170, 113, 0.1);
        transition: background-color 0.3s;
      }
      #character-details-modal .attribute-item:hover {
        background-color: rgba(201, 170, 113, 0.05);
      }
      #character-details-modal .attribute-item:last-child {
        border-bottom: none;
      }

      .details-progress-bar {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        overflow: hidden;
        border: 1px solid #8b7355;
        margin-top: 8px;
      }

      .details-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #6a11cb, #2575fc);
        border-radius: 3px;
        transition: width 0.5s ease-in-out;
      }

      /* --- 归墟系统模态框美化 --- */
      #guixu-system-modal .modal-content {
        background: radial-gradient(circle, rgba(45, 27, 61, 0.9) 0%, rgba(15, 15, 35, 0.95) 100%);
        border: 1px solid #8b7355;
        box-shadow: 0 0 25px rgba(201, 170, 113, 0.3);
      }

      #guixu-system-modal .attribute-item {
        padding: 10px 4px; /* 增加垂直内边距 */
        font-size: 13px; /* 放大字体 */
        border-bottom: 1px solid rgba(201, 170, 113, 0.1);
      }
      #guixu-system-modal .attribute-item:last-child {
        border-bottom: none;
      }

      /* --- 人物关系样式 --- */
      .relationship-card {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(201, 170, 113, 0.3);
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 15px;
      }
      .relationship-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(201, 170, 113, 0.2);
      }
      .relationship-name {
        font-size: 18px;
        font-weight: bold;
      }
      .relationship-relation {
        font-size: 14px;
        color: #a09c91;
        font-style: italic;
      }
      .relationship-body {
        font-size: 13px;
        line-height: 1.7;
      }
      .relationship-body p {
        margin-bottom: 8px;
      }
      .relationship-meta {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #a09c91;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(201, 170, 113, 0.2);
      }
      .favorability-bar-container {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        margin-top: 4px;
        border: 1px solid #8b7355;
      }
      .favorability-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #8b4513, #cd853f);
        border-radius: 3px;
      }
      .event-history-details {
        margin-top: 15px;
      }
      .event-history-summary {
        cursor: pointer;
        color: #c9aa71;
        font-style: italic;
      }
      .event-history-list {
        list-style-type: disc;
        padding-left: 20px;
        margin-top: 8px;
        color: #a09c91;
      }

      /* --- 新增：本世历程详细信息样式 --- */
      .detail-section {
        margin-bottom: 10px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.1);
        border-radius: 4px;
        font-size: 12px;
        line-height: 1.5;
      }

      .detail-section strong {
        color: #c9aa71;
        margin-right: 5px;
      }

      .timeline-location {
        font-size: 12px;
        color: #8b7355;
        margin: 5px 0;
        font-style: italic;
      }


      .timeline-detailed-info {
        animation: fadeIn 0.3s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */
      /* --- 新增：移动端适配样式 --- */
      /* --- 新增：视图切换按钮样式 --- */
      .view-toggle-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 35px;
        height: 35px;
        background: rgba(15, 15, 35, 0.8);
        border: 1px solid #c9aa71;
        color: #c9aa71;
        border-radius: 50%;
        cursor: pointer;
        z-index: 100;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s;
      }
      .view-toggle-btn:hover {
        background-color: rgba(45, 27, 61, 0.9);
      }

      /* THÊM MỚI: Định vị nút toàn màn hình */
      #fullscreen-toggle-btn {
        right: 60px; /* Đặt vị trí bên trái nút chuyển đổi view */
      }
	  /* THÊM MỚI: Ẩn nút toàn màn hình khi ở chế độ mobile */
	  .mobile-view #fullscreen-toggle-btn {
        display: none;
      }
	  
      /* --- 新增：移动端视图样式 (由JS切换) --- */
      .mobile-view .guixu-root-container {
        height: 100%;
        aspect-ratio: unset; /* 在移动端移除PC端的宽高比限制 */
      }

      .mobile-view .game-container {
        grid-template-columns: 1fr; /* 单列布局 */
        grid-template-rows: auto 1fr auto auto auto; /* 新顺序: 顶, 中, 左, 右, 底 */
        height: auto; /* 覆盖固定高度, 让其自适应内容 */
        gap: 0;
      }

      /* 让所有面板占据整行 */
      .mobile-view .top-status,
      .mobile-view .character-panel,
      .mobile-view .main-content,
      .mobile-view .interaction-panel,
      .mobile-view .bottom-status {
        grid-column: 1 / -1;
      }

      .mobile-view .character-panel {
        grid-row: 3; /* 移动到正文下方 */
        border-right: none;
        border-bottom: 1px solid #c9aa71;
        max-height: 250px; /* 给一个最大高度，内容可滚动 */
      }

      .mobile-view .main-content {
        grid-row: 2; /* 移动到顶部下方 */
      }

      .mobile-view .interaction-panel {
        grid-row: 4;
        border-left: none;
        border-top: 1px solid #c9aa71;
        flex-direction: row; /* 按钮横向排列 */
        flex-wrap: wrap; /* 允许换行 */
        justify-content: center;
        gap: 8px;
        padding: 8px;
      }

      .mobile-view .interaction-btn {
        flex-grow: 1; /* 让按钮填充空间 */
        min-width: 120px; /* 最小宽度 */
      }

      .mobile-view .world-line-section {
        width: 100%;
        display: flex;
        justify-content: space-around;
      }
	  /* THÊM MỚI */
      .mobile-view .world-line-section > div {
        flex-direction: row;
      }
	  
      .mobile-view .bottom-status {
        flex-direction: column; /* 垂直堆叠 */
        height: auto;
        padding: 8px;
      }

      .mobile-view .quick-send-container {
        width: 100%;
        flex-direction: column;
      }

      .mobile-view .quick-send-input {
        width: 100%;
      }

      .mobile-view #quick-command-popup {
        width: 90%;
        left: 5%;
        right: 5%;
        bottom: 110px; /* 调整位置 */
      }

      /* 调整字体大小 */
      .mobile-view .status-value {
        font-size: 12px;
      }
      .mobile-view .status-label {
        font-size: 10px;
      }
      .mobile-view .section-title {
        font-size: 12px;
      }
      .mobile-view .attribute-item {
        font-size: 11px;
      }
      .mobile-view .game-text-container {
        font-size: 13px;
      }
      .mobile-view .interaction-btn {
        font-size: 11px;
      }
    </style>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */
      /* --- 自定义确认模态框 --- */
      .confirm-modal-content {
        width: auto;
        max-width: 400px;
        height: auto;
        max-height: none;
        text-align: center;
        padding: 30px;
      }
      .confirm-modal-message {
        font-size: 16px;
        color: #ff6b6b; /* 红色警告 */
        margin-bottom: 25px;
        line-height: 1.6;
      }
      .confirm-modal-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
      }
    </style>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */
      /* --- 新增：存档管理模态框样式 --- */
      .clear-saves-btn {
        background: #8b0000;
        color: #fff;
        border: 1px solid #ff6b6b;
        padding: 4px 10px;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.3s;
        margin-left: auto; /* 将按钮推到右边 */
      }
      .clear-saves-btn:hover {
        background: #a52a2a;
      }
      #save-slots-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .save-slot {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(201, 170, 113, 0.3);
        border-radius: 5px;
        padding: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .save-slot-info {
        flex-grow: 1;
      }

      .save-slot-info .slot-name {
        font-size: 16px;
        color: #e0dcd1;
      }

      .save-slot-info .slot-time {
        font-size: 12px;
        color: #8b7355;
        margin-top: 5px;
      }
      .save-slot-info .slot-summary {
        font-size: 11px;
        color: #a09c91;
        margin-top: 8px;
        font-style: italic;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 450px; /* 根据模态框宽度调整 */
      }

      .save-slot-actions {
        display: flex;
        gap: 10px;
      }
    </style>
    <style>
      /* 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享 */
      /* --- 新增：等待悬浮窗 --- */
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @keyframes god-tier-animation {
        0% {
          background-position: -200% center;
        }
        100% {
          background-position: 200% center;
        }
      }

      .waiting-spinner {
        width: 24px;
        height: 24px;
        border: 3px solid rgba(201, 170, 113, 0.3);
        border-top-color: #c9aa71;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex-shrink: 0;
      }

      .waiting-popup {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 15, 35, 0.8);
        color: #c9aa71;
        padding: 15px 25px;
        border-radius: 8px;
        border: 1px solid #c9aa71;
        z-index: 9999;
        font-size: 16px;
        box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
        line-height: 1.6;
        display: flex;
        align-items: center;
        gap: 20px;
        width: 450px; /* 拉长悬浮框 */
        max-width: 90%;
      }
    </style>
  </head>
  <body>
  <!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
  <div class="guixu-root-container">
    <!-- MỚI: Nút toàn màn hình -->
    <button id="fullscreen-toggle-btn" class="view-toggle-btn" title="Toàn màn hình">⛶</button>
    <!-- Mới: Nút chuyển đổi giao diện -->
    <!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
    <button id="view-toggle-btn" class="view-toggle-btn" title="Chuyển đổi giao diện">📱</button>
    <div class="game-container">
      <!-- Thanh trạng thái trên cùng -->
      <!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
      <div class="top-status">
        <div class="status-item">
          <div class="status-label">Cảnh Giới</div>
          <div id="val-jingjie" class="status-value">...</div>
        </div>
        <div class="status-item">
          <div class="status-label">Niên Kỷ Hiện Tại</div>
          <div id="val-jinian" class="status-value">...</div>
        </div>
        <div class="status-item">
          <div class="status-label">Quy Khư Nạp Năng</div>
          <div id="val-guixu-charge-text" class="status-value">...%</div>
          <div id="bar-guixu-charge" class="guixu-charge">
            <div class="guixu-fill"></div>
          </div>
        </div>
      </div>

      <!-- Bảng nhân vật bên trái -->
      <!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
      <div class="character-panel">
        <div class="panel-section">
          <div class="section-title">Thuộc Tính Cốt Lõi <span style="font-size: 10px; color: #8b7355">(Hiện tại/Giới hạn)</span></div>
          <div class="attributes-list">
            <div class="attribute-item">
              <span class="attribute-name">Pháp Lực</span><span id="attr-fali" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Thần Hải</span><span id="attr-shenhai" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Đạo Tâm</span><span id="attr-daoxin" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Không Tốc</span><span id="attr-kongsu" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Khí Vận</span><span id="attr-qiyun" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Tuổi Sinh Lý</span><span id="attr-shengli" class="attribute-value">...</span>
            </div>
            <div class="attribute-item">
              <span class="attribute-name">Tuổi Tâm Lý</span><span id="attr-xinli" class="attribute-value">...</span>
            </div>
          </div>
        </div>
        <div class="panel-section">
          <div class="section-title">Thiên Phú & Linh Căn</div>
          <div id="talent-linggen-list" class="attributes-list">
            <!-- Thiên phú và Linh căn sẽ được điền tự động vào đây -->
          </div>
        </div>
        <div class="panel-section">
          <div class="section-title">Trang Bị Hiện Tại</div>
          <div class="equipment-grid">
            <div id="equip-wuqi" class="equipment-slot">Vũ Khí</div>
            <div id="equip-fangju" class="equipment-slot">Phòng Cụ</div>
            <div id="equip-shipin" class="equipment-slot">Phụ Kiện</div>
            <div id="equip-fabao1" class="equipment-slot">Pháp Bảo</div>
            <div id="equip-zhuxiuGongfa" class="equipment-slot">Công Pháp Chủ Tu</div>
            <div id="equip-fuxiuXinfa" class="equipment-slot">Tâm Pháp Phụ Tu</div>
          </div>
        </div>
      </div>

      <!-- Khu vực nội dung trung tâm -->
      <!-- Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở -->
      <div class="main-content">
        <div id="game-text-display" class="game-text-container">
          <!-- Văn bản chính của trò chơi do AI tạo ra sẽ hiển thị ở đây -->
          <gametxt> Chào mừng đến với thế giới của 《Quy Khư》. Túc mệnh của ngươi, bắt đầu từ đây. </gametxt>
        </div>
      </div>

      <!-- Bảng tương tác bên phải -->
      <div class="interaction-panel">
        <button id="btn-inventory" class="interaction-btn">Túi Đồ</button>
        <button id="btn-relationships" class="interaction-btn">Quan Hệ Nhân Vật</button>
        <button id="btn-command-center" class="interaction-btn">Trung Tâm Mệnh Lệnh</button>
        <button id="btn-character-details" class="interaction-btn">Chi Tiết Nhân Vật</button>
        <button id="btn-guixu-system" class="interaction-btn">Hệ Thống Quy Khư</button>
        <button id="btn-show-extracted" class="interaction-btn">Xem Nội Dung Trích Xuất</button>
        <button id="btn-save-load-manager" class="interaction-btn">Lưu Trữ/Tải Lại</button>
        <!-- Mới: Mô-đun điều khiển Lorebook thống nhất -->
        <div id="world-book-controls" class="panel-section" style="padding: 8px; margin-top: 10px">
          <div class="section-title" style="font-size: 11px; margin-bottom: 6px">Điều Khiển Lorebook</div>
          <div style="display: flex; flex-direction: column; gap: 8px">
            <div style="display: flex; align-items: center; justify-content: space-between">
              <label for="unified-index-input" style="font-size: 11px; color: #8b7355">Số thứ tự Đọc/Ghi:</label>
              <input type="number" id="unified-index-input" value="1" min="1" style="width: 60px; background: rgba(0, 0, 0, 0.5); border: 1px solid #8b7355; color: #e0dcd1; border-radius: 4px; padding: 4px; font-size: 12px" />
            </div>
            <div style="display: flex; align-items: center; gap: 6px">
              <input type="checkbox" id="auto-toggle-lorebook-checkbox" style="cursor: pointer" />
              <label for="auto-toggle-lorebook-checkbox" class="auto-write-label" style="font-size: 11px">Tự động bật/tắt Lorebook</label>
            </div>
          </div>
        </div>
        <!-- Nút dòng thời gian đã được chuyển đến giao diện lưu trữ -->
        <div class="world-line-section">
          <div class="world-line-title">Nhìn Lại Dòng Thời Gian</div>
          <div style="display: flex; gap: 10px; justify-content: center">
            <button id="btn-view-journey-main" class="interaction-btn primary-btn" style="flex-grow: 1; white-space: nowrap">Hành Trình Kiếp Này</button>
            <button id="btn-view-past-lives-main" class="interaction-btn primary-btn" style="flex-grow: 1; white-space: nowrap">Sóng Nước Kiếp Xưa</button>
          </div>
        </div>
      </div>

      <!-- Hiệu ứng trạng thái ở dưới cùng -->
      <div id="bottom-status-container" class="bottom-status">
        <div id="status-effects-wrapper" style="display: flex; gap: 8px; overflow-x: auto">
          <!-- Hiệu ứng trạng thái sẽ được JS điền tự động -->
          <div class="status-effect">
            <div class="effect-icon"></div>
            <span>Hiện không có trạng thái hiệu ứng</span>
          </div>
        </div>
        <div class="quick-send-container">
          <button id="btn-quick-commands" class="interaction-btn" style="padding: 5px 12px">Mệnh Lệnh Hiện Tại</button>
          <textarea id="quick-send-input" class="quick-send-input" placeholder="Vui lòng nhập phản hồi tại đây..."></textarea>
          <button id="btn-quick-send" class="interaction-btn" style="padding: 5px 12px">Gửi</button>
        </div>
      </div>
    </div>

    <!-- Các cửa sổ modal khác nhau (ĐÃ DI CHUYỂN VÀO TRONG .guixu-root-container) -->
    <div id="inventory-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Túi Đồ Của Ta</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Nội dung túi đồ sẽ được JS điền tự động -->
        </div>
      </div>
    </div>
    <div id="relationships-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Quan Hệ Nhân Vật</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Nội dung quan hệ nhân vật sẽ được JS điền tự động -->
        </div>
      </div>
    </div>
    <div id="history-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 id="history-modal-title" class="modal-title">Nhìn Lại Lịch Sử</h2>
          <div style="display: flex; align-items: center; gap: 10px; margin-left: auto"></div>
          <button class="modal-close-btn" style="margin-left: 15px">&times;</button>
        </div>
        <div id="history-modal-body" class="modal-body">
          <!-- Nội dung Hành trình/Gợn sóng sẽ được JS điền tự động -->
        </div>
      </div>
    </div>
    <div id="command-center-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Trung Tâm Mệnh Lệnh</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Mệnh lệnh sẽ được JS điền tự động -->
        </div>
        <div class="command-center-footer">
          <button id="btn-refresh-storage" class="interaction-btn">Làm mới bộ nhớ đệm</button>
          <div>
            <button id="btn-clear-commands" class="interaction-btn">Xóa sạch mệnh lệnh</button>
            <button id="btn-execute-commands" class="interaction-btn primary-btn" style="margin-left: 10px">
              Chấp hành mệnh lệnh
            </button>
          </div>
        </div>
      </div>
    </div>
    <div id="extracted-content-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Nội dung AI được trích xuất lần cuối</h2>
          <div style="display: flex; align-items: center; gap: 10px; margin-left: auto"></div>
          <button class="modal-close-btn" style="margin-left: 15px">&times;</button>
        </div>
        <div class="modal-body">
          <div class="panel-section">
            <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
              <span>Hành Trình Kiếp Này</span>
              <button
                id="btn-write-journey"
                class="interaction-btn"
                style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
              >
                Ghi vào Lorebook
              </button>
            </div>
            <pre
              id="extracted-journey"
              style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
            >
Không có nội dung</pre
            >
          </div>
          <div class="panel-section">
            <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
              <span>Sóng Nước Kiếp Xưa</span>
              <button
                id="btn-write-past-lives"
                class="interaction-btn"
                style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
              >
                Ghi vào Lorebook
              </button>
            </div>
            <pre
              id="extracted-past-lives"
              style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
            >
Không có nội dung</pre
            >
          </div>
          <div class="panel-section">
            <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
              <span>Chế độ tiểu thuyết</span>
              <button
                id="btn-write-novel-mode"
                class="interaction-btn"
                style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
              >
                Ghi vào Lorebook
              </button>
            </div>
            <pre
              id="extracted-novel-mode"
              style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
            >
Chế độ tiểu thuyết đã tắt</pre
            >
          </div>
          <div class="panel-section">
            <div class="section-title" style="display: flex; justify-content: space-between; align-items: center">
              <span>Trích xuất nhân vật</span>
              <button
                id="btn-write-character-card"
                class="interaction-btn"
                style="padding: 4px 8px; font-size: 12px; margin-left: 10px"
              >
                Ghi vào Lorebook
              </button>
            </div>
            <pre
              id="extracted-character-card"
              style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
            >
Không có nội dung</pre
            >
          </div>
          <!-- Mới: Chuyển tùy chọn tự động ghi vào bên trong modal này -->
          <div class="auto-write-section">
            <input type="checkbox" id="novel-mode-enabled-checkbox" />
            <label for="novel-mode-enabled-checkbox" class="auto-write-label">Bật chế độ tiểu thuyết</label>
            <input type="checkbox" id="auto-write-checkbox" checked style="margin-left: 20px" />
            <label for="auto-write-checkbox" class="auto-write-label">Tự động ghi Hành trình/Gợn sóng</label>
          </div>
          <details class="panel-section" style="margin-top: 15px">
            <summary class="section-title" style="cursor: pointer; list-style: none">
              <span>Thay đổi biến lần này</span>
            </summary>
            <pre
              id="extracted-variable-changes"
              style="
                  white-space: pre-wrap;
                  word-wrap: break-word;
                  color: #e0dcd1;
                  font-size: 12px;
                  padding: 10px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  min-height: 50px;
                "
            >
Không có nội dung</pre
            >
          </details>
        </div>
      </div>
    </div>

    <!-- Mới: Cửa sổ modal chi tiết nhân vật -->
    <div id="character-details-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Chi Tiết Nhân Vật</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Thuộc tính chi tiết sẽ được JS điền tự động -->
        </div>
      </div>
    </div>

    <!-- Mới: Cửa sổ modal hệ thống Quy Khư -->
    <div id="guixu-system-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Hệ Thống Quy Khư</h2>
          <button class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Thông tin hệ thống Quy Khư sẽ được JS điền tự động -->
        </div>
      </div>
    </div>


    <!-- Hộp thoại chi tiết trang bị (di chuyển đến cuối body) -->
    <div id="equipment-tooltip"></div>

    <!-- Mới: Hộp thoại xác nhận tùy chỉnh -->
    <div id="custom-confirm-modal" class="modal-overlay">
      <div class="modal-content confirm-modal-content">
        <div id="custom-confirm-message" class="confirm-modal-message">
          <!-- Tin nhắn sẽ được JS điền -->
        </div>
        <div class="confirm-modal-buttons">
          <button id="custom-confirm-btn-ok" class="interaction-btn primary-btn">Xác nhận</button>
          <button id="custom-confirm-btn-cancel" class="interaction-btn">Hủy</button>
        </div>
      </div>
    </div>

    <!-- Mới: Menu lệnh nhanh bật lên -->
    <div id="quick-command-popup">
      <!-- Nội dung sẽ được JS điền tự động -->
    </div>

    <!-- Mới: Cửa sổ modal quản lý Lưu/Tải -->
    <div id="save-load-modal" class="modal-overlay">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Quản lý Lưu trữ</h2>
          <div style="display: flex; gap: 10px; margin-left: auto;">
            <button id="btn-clear-all-saves" class="clear-saves-btn">Xóa tất cả tệp lưu</button>
          </div>
          <button class="modal-close-btn" style="margin-left: 15px;">&times;</button>
        </div>
        <div id="save-slots-container" class="modal-body">
          <!-- Các ô lưu trữ sẽ được JS điền tự động -->
        </div>
      </div>
    </div>
  </div><!-- thẻ đóng của .guixu-root-container -->

  <script>
    // Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở
    // --- SillyTavern Global API ---
    // These are provided by the SillyTavern environment at runtime.
      // We will check for their existence before using them.
      /* global TavernHelper, eventOn, tavern_events, getChatMessages, getCurrentMessageId, _ */

      // --- Main Application Logic ---
      (function () {
        'use strict';

        // --- API Availability Check ---
        if (
          typeof TavernHelper === 'undefined' ||
          typeof eventOn === 'undefined' ||
          typeof tavern_events === 'undefined' ||
          typeof getChatMessages === 'undefined' ||
          typeof getCurrentMessageId === 'undefined' ||
          typeof _ === 'undefined'
        ) {
          console.error('TavernHelper API, event system, or lodash not found.');
          document.addEventListener('DOMContentLoaded', () => {
            document.body.innerHTML =
              '<h1 style="color: red; text-align: center;">Lỗi: Không tìm thấy API môi trường SillyTavern hoặc phiên bản không tương thích</h1><p style="color:grey; text-align:center;">Vui lòng đảm bảo đã cài đặt và kích hoạt tiện ích mở rộng TavernHelper.</p>';
          });
          return;
        }

        // --- Core Application Object for UI Interactions ---
        // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
        const GuixuManager = {
          listenersBound: false, // Mới: Cờ để ngăn chặn việc gán lại trình lắng nghe sự kiện
          // Theo dõi trạng thái của các vật phẩm đã trang bị
          // **Sửa lỗi logic**: equippedItems bây giờ lưu trữ đối tượng vật phẩm hoàn chỉnh, không chỉ ID
          equippedItems: {
            wuqi: null,
            fangju: null,
            shipin: null,
            fabao1: null,
            zhuxiuGongfa: null,
            fuxiuXinfa: null,
          },
          currentMvuState: null, // Mới: Dùng để lưu trữ trạng thái mvu mới nhất
          pendingActions: [], // Giỏ hàng/Hàng đợi lệnh
          baseAttributes: {}, // Lưu trữ các thuộc tính gốc được tải từ mvu
          calculatedMaxAttributes: {}, // Mới: Dùng để lưu trữ giới hạn thuộc tính sau khi tính toán
          lastExtractedJourney: null,
          lastExtractedPastLives: null,
          lastExtractedNovelText: null, // Mới: Dùng để lưu trữ văn bản gốc được trích xuất
          lastExtractedCharacterCard: null, // Mới: Dùng để lưu trữ thẻ nhân vật được trích xuất
          lastExtractedVariables: null, // Mới: Dùng để lưu trữ các thay đổi biến
          lastSentPrompt: null, // Mới: Dùng để lưu trữ lời nhắc hoàn chỉnh được gửi đến AI
          isNovelModeEnabled: false, // Mới: Trạng thái bật/tắt chế độ tiểu thuyết
          isAutoWriteEnabled: true, // Mặc định bật tự động ghi
          autoWriteIntervalId: null, // Dùng để lưu trữ ID bộ hẹn giờ thăm dò
          novelModeAutoWriteIntervalId: null, // Mới: ID thăm dò tự động ghi cho chế độ tiểu thuyết
          isMobileView: false, // Mới: Theo dõi trạng thái giao diện di động
          unifiedIndex: 1, // Mới: Số thứ tự đọc/ghi thống nhất
          isAutoToggleLorebookEnabled: false, // Mới: Trạng thái tự động bật/tắt Lorebook
          autoToggleIntervalId: null, // Mới: ID bộ hẹn giờ thăm dò
          listenersBound: false, // 新增：防止事件监听器重复绑定的标志
          // --- 新增：处理所有动作的核心函数 ---
          waitingMessages: [
            'Ô ô ô ô, Mộng Tinh đại nhân vĩ đại hỡi, xin hãy hồi đáp cho tín đồ thành kính {{user}} của ngài đi mà......',
            'Mộng Tinh đại nhân, chúng con kính yêu ngài!! Xin hãy hồi đáp cho con đi!!',
            'Mộng Tinh đại nhân đang phản hồi yêu cầu của bạn, sẽ hồi đáp trong bảy ngày làm việc',
            'Đang cầu nguyện với Mộng Tinh vĩ đại...... huhuhu người nhanh lên một chút được không',
			'Đang cầu xin Decal tốt bụng thương xót......'
          ],

          showWaitingMessage() {
            this.hideWaitingMessage(); // Ensure only one is visible
            const message = this.waitingMessages[Math.floor(Math.random() * this.waitingMessages.length)];
            const msgElement = document.createElement('div');
            msgElement.id = 'waiting-popup';
            msgElement.className = 'waiting-popup';
            // Update HTML structure to include spinner
            msgElement.innerHTML = `
              <div class="waiting-spinner"></div>
              <span>${message}</span>
            `;
            const container = document.querySelector('.guixu-root-container');
            if (container) {
                container.appendChild(msgElement);
            }
          },

          hideWaitingMessage() {
              const existingMsg = document.getElementById('waiting-popup');
              if (existingMsg) {
                  existingMsg.remove();
              }
          },

          // --- 新增：视图切换核心功能 ---
          toggleViewMode() {
            this.isMobileView = !this.isMobileView;
            const container = document.querySelector('.guixu-root-container');
            const btn = document.getElementById('view-toggle-btn');
            if (container && btn) {
              if (this.isMobileView) {
                container.classList.add('mobile-view');
                btn.textContent = '💻'; // Switch to desktop icon
                btn.title = 'Chuyển sang giao diện máy tính';
              } else {
                container.classList.remove('mobile-view');
                btn.textContent = '📱'; // Switch to mobile icon
                btn.title = 'Chuyển sang giao diện di động';
              }
            }
            this.saveViewMode();
          },
		  
		  /* THÊM MỚI: Hàm xử lý Fullscreen */
          toggleFullscreen() {
            const container = document.querySelector('.guixu-root-container');
            if (!container) return;

            // Kiểm tra xem có phần tử nào đang ở chế độ toàn màn hình không
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;

            if (!isFullscreen) {
              // Nếu không, yêu cầu vào chế độ toàn màn hình
              if (container.requestFullscreen) {
                container.requestFullscreen().catch(err => {
                  console.error(`Lỗi khi cố gắng bật chế độ toàn màn hình: ${err.message} (${err.name})`);
                });
              } else if (container.webkitRequestFullscreen) { // Dành cho Safari
                container.webkitRequestFullscreen();
              }
            } else {
              // Nếu có, thoát khỏi chế độ toàn màn hình
              if (document.exitFullscreen) {
                document.exitFullscreen();
              } else if (document.webkitExitFullscreen) { // Dành cho Safari
                document.webkitExitFullscreen();
              }
            }
          },

          saveViewMode() {
            try {
              localStorage.setItem('guixu_view_mode', this.isMobileView ? 'mobile' : 'desktop');
            } catch (e) {
              console.error('Lưu chế độ xem thất bại:', e);
            }
          },

          loadViewMode() {
            try {
              const savedMode = localStorage.getItem('guixu_view_mode');
              // 仅当保存的模式为 'mobile' 时，才在加载时切换到移动视图
              if (savedMode === 'mobile') {
                this.isMobileView = true; // 设置初始状态
                const container = document.querySelector('.guixu-root-container');
                const btn = document.getElementById('view-toggle-btn');
                if (container && btn) {
                  container.classList.add('mobile-view');
                  btn.textContent = '💻';
                  btn.title = 'Chuyển sang giao diện máy tính';
                }
              } else {
                this.isMobileView = false; // 确保默认是桌面视图
              }
            } catch (e) {
              console.error('Tải chế độ xem thất bại:', e);
            }
          },

          formatMessageContent(text) {
            if (!text) return '';
            // 首先，处理换行符。AI响应似乎使用文字“\\n”。
            let processedText = text.replace(/\\n/g, '<br />');

            // 语言: “...” 或 「...」 -> 保留引号, 应用样式
            processedText = processedText.replace(/(“[^”]+”|「[^」]+」)/g, match => {
              return `<span class="text-language">${match}</span>`;
            });

            // 心理: *...* -> 移除星号, 应用样式
            processedText = processedText.replace(/\*([^*]+)\*/g, (match, p1) => {
              return `<span class="text-psychology">${p1}</span>`;
            });

            // 景物: 【...】 -> 移除括号, 应用样式, 且不匹配纯数字内容
            processedText = processedText.replace(/【([^】\d]+[^】]*)】/g, (match, p1) => {
              return `<span class="text-scenery">${p1}</span>`;
            });

            return processedText;
          },

          async init() {
            console.log('Khởi tạo trình quản lý tương tác UI Quy Khư...');
            this.bindStaticListeners();
            this.applyRandomBackground();
            await this.updateDynamicData(); // Initial data load
            this.loadAutoWriteState(); // 加载自动写入状态
            this.loadNovelModeState(); // 加载小说模式状态
            this.loadEquipmentState(); // 加载已装备物品状态
            this.loadPendingActions(); // 加载待处理指令
            this.loadViewMode(); // 新增：加载用户保存的视图模式
            this.loadUnifiedIndex(); // 新增：加载统一的读写序号
            this.loadAutoToggleState(); // 新增：加载自动开关状态
 
              // 已移除 MESSAGE_SWIPED 事件监听器，以避免与核心mvu脚本冲突。
            // UI刷新现在通过 handleAction 内部的主动调用来完成。
          },

          // --- Data Handling ---
          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          async updateDynamicData() {
            try {
              // 加载核心mvu数据
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0 && messages[0].data) {
                // 缓存完整的 mvu 状态，而不仅仅是 stat_data
                this.currentMvuState = messages[0].data;
                this.renderUI(this.currentMvuState.stat_data);
              } else {
                console.warn('Không thể tải dữ liệu mvu từ tin nhắn hiện tại.');
              }

              // 新增：加载并显示当前场景正文
              // 此函数现在处理自己的文本格式化。
              await this.loadAndDisplayCurrentScene();
            } catch (error) {
              console.error('Lỗi khi cập nhật dữ liệu động của Quy Khư:', error);
            }
          },

          // 新增：统一的UI渲染函数
          renderUI(data) {
            if (!data) {
              console.warn('Gọi RenderUI thất bại: không có dữ liệu được cung cấp.');
              return;
            }
            const updateText = (id, value, style = '') => {
              const el = document.getElementById(id);
              if (el) {
                el.innerText = value;
                if (style) {
                  el.setAttribute('style', style);
                }
              }
            };

            // BUGFIX: Per the variable definition, the actual value is the first element of the array.
            const jingjieValue = this.SafeGetValue(data, 'Cảnh Giới Hiện Tại.0', '...');
            const match = jingjieValue.match(/^(\S{2})/);
            const jingjieTier = match ? match[1] : '';
            const jingjieStyle = this.getTierStyle(jingjieTier);
            updateText('val-jingjie', jingjieValue, jingjieStyle);
            updateText('val-jinian', this.SafeGetValue(data, 'Niên Đại Thời Gian Hiện Tại'));
            const charge = this.SafeGetValue(data, 'Thời Gian Nạp Quy Khư', '0');
            updateText('val-guixu-charge-text', `${charge}%`);
            const chargeBar = document.getElementById('bar-guixu-charge');
            if (chargeBar) chargeBar.style.setProperty('--guixu-charge', `${charge}%`);

            // 此处不再需要填充 this.baseAttributes，因为 updateDisplayedAttributes 会直接从 stat_data 读取
            
            this.updateTalentAndLinggen(data);
            this.loadEquipmentFromMVU(data);
            this.updateDisplayedAttributes(); // 核心渲染函数

            const statusWrapper = document.getElementById('status-effects-wrapper');
            if (statusWrapper) {
              const statuses = _.get(data, 'Trạng Thái Hiện Tại.0', []);
              if (Array.isArray(statuses) && statuses.length > 0 && statuses[0] !== '$__META_EXTENSIBLE__$') {
                statusWrapper.innerHTML = statuses
                  .map(s => {
                    let statusText = 'Trạng thái không xác định';
                    if (typeof s === 'string') {
                      statusText = s;
                    } else if (typeof s === 'object' && s !== null) {
                      statusText = this.SafeGetValue(s, 'name', 'Trạng thái không xác định');
                    }
                    return `<div class="status-effect"><div class="effect-icon"></div><span>${statusText}</span></div>`;
                  })
                  .join('');
              } else {
                statusWrapper.innerHTML =
                  '<div class="status-effect"><div class="effect-icon"></div><span>Hiện không có trạng thái hiệu ứng</span></div>';
              }
            }
          },

          // --- Event Listeners for Buttons and Modals ---
          bindStaticListeners() {
            if (this.listenersBound) return; // 如果已经绑定过，则直接返回
			/* THÊM MỚI: Trình lắng nghe sự kiện click Fullscreen */
            document.getElementById('fullscreen-toggle-btn')?.addEventListener('click', () => this.toggleFullscreen());
            // 新增：为视图切换按钮绑定监听器
            document.getElementById('view-toggle-btn')?.addEventListener('click', () => this.toggleViewMode());
            
            // 新增：为世界书序号输入框绑定监听
            // 新增：为统一的序号输入框绑定监听
            document.getElementById('unified-index-input')?.addEventListener('change', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (!isNaN(newIndex) && newIndex > 0) {
                    this.unifiedIndex = newIndex;
                    this.saveUnifiedIndex();
                    this.showTemporaryMessage(`Số thứ tự đọc/ghi Lorebook đã cập nhật thành ${newIndex}`);
                    // 如果自动开关是开启的，立即更新启用的条目
                    if (this.isAutoToggleLorebookEnabled) {
                        this.startAutoTogglePolling();
                    }
                } else {
                    e.target.value = this.unifiedIndex; // 如果输入无效，则恢复
                }
            });

            // 新增：为自动开关世界书复选框绑定监听
            document.getElementById('auto-toggle-lorebook-checkbox')?.addEventListener('change', (e) => {
                this.isAutoToggleLorebookEnabled = e.target.checked;
                this.saveAutoToggleState();
                this.showTemporaryMessage(`Tự động bật/tắt Lorebook đã được ${this.isAutoToggleLorebookEnabled ? 'bật' : 'tắt'}`);
                if (this.isAutoToggleLorebookEnabled) {
                  this.startAutoTogglePolling();
                } else {
                  this.stopAutoTogglePolling();
                }
            });

            document.getElementById('btn-inventory')?.addEventListener('click', () => this.showInventory());
            document.getElementById('btn-relationships')?.addEventListener('click', () => this.showRelationships());
            document.getElementById('btn-command-center')?.addEventListener('click', () => this.showCommandCenter());
            document
              .getElementById('btn-character-details')
              ?.addEventListener('click', () => this.showCharacterDetails());
            document.getElementById('btn-guixu-system')?.addEventListener('click', () => this.showGuixuSystem());
            document.getElementById('btn-show-extracted')?.addEventListener('click', () => this.showExtractedContent());
            // 主界面的世界线回顾按钮
            document.getElementById('btn-view-journey-main')?.addEventListener('click', () => this.showJourney());
            document.getElementById('btn-view-past-lives-main')?.addEventListener('click', () => this.showPastLives());
            document.getElementById('btn-save-load-manager')?.addEventListener('click', () => this.showSaveLoadManager());
            document.getElementById('btn-clear-all-saves')?.addEventListener('click', () => this.clearAllSaves());
            // 时间线备份/恢复事件监听器已移除，功能已集成到存档系统中
 
              // 为写入世界书按钮绑定监听器
             document
              .getElementById('btn-write-journey')
              ?.addEventListener('click', () => this.writeJourneyToLorebook());
            document
              .getElementById('btn-write-past-lives')
              ?.addEventListener('click', () => this.writePastLivesToLorebook());
            document
              .getElementById('btn-write-novel-mode')
              ?.addEventListener('click', () => this.writeNovelModeToLorebook());

            document
              .getElementById('btn-write-character-card')
              ?.addEventListener('click', () => this.writeCharacterCardToLorebook());
            // 为自动写入复选框绑定监听器，并增加状态保存
            const autoWriteCheckbox = document.getElementById('auto-write-checkbox');
            if (autoWriteCheckbox) {
              autoWriteCheckbox.addEventListener('change', e => {
                this.isAutoWriteEnabled = e.target.checked;
                this.saveAutoWriteState(this.isAutoWriteEnabled);
                this.showTemporaryMessage(`Tự động ghi Hành trình/Gợn sóng đã ${this.isAutoWriteEnabled ? 'bật' : 'tắt'}`);
                if (this.isAutoWriteEnabled) {
                  this.startAutoWritePolling();
                } else {
                  this.stopAutoWritePolling();
                }
              });
            }

            // 为小说模式复选框绑定监听器
            const novelModeCheckbox = document.getElementById('novel-mode-enabled-checkbox');
            if (novelModeCheckbox) {
              novelModeCheckbox.addEventListener('change', e => {
                this.isNovelModeEnabled = e.target.checked;
                this.saveNovelModeState(this.isNovelModeEnabled);
                this.showTemporaryMessage(`Tự động ghi chế độ tiểu thuyết đã ${this.isNovelModeEnabled ? 'bật' : 'tắt'}`);

                // 新逻辑：此开关只控制轮询，不触发UI刷新
                if (this.isNovelModeEnabled) {
                  this.startNovelModeAutoWritePolling();
                } else {
                  this.stopNovelModeAutoWritePolling();
                }

                // 手动更新标签文本以提供即时反馈
                const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
                if (label) {
                  label.textContent = `Bật chế độ tiểu thuyết`; // Restore original text
                }
                // 刷新打开的模态框以更新按钮状态和提示
                if (document.getElementById('extracted-content-modal').style.display === 'flex') {
                  this.showExtractedContent();
                }
              });
            }

            // 指令中心按钮
            document
              .getElementById('btn-execute-commands')
              ?.addEventListener('click', () => this.executePendingActions());
            document.getElementById('btn-clear-commands')?.addEventListener('click', () => this.clearPendingActions());
            document.getElementById('btn-refresh-storage')?.addEventListener('click', () => this.refreshLocalStorage());

            document
              .querySelectorAll('.modal-close-btn')
              .forEach(btn => btn.addEventListener('click', () => this.closeAllModals()));
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
              overlay.addEventListener('click', e => {
                if (e.target === overlay) this.closeAllModals();
              });
            });

            // 事件委托：背包内的点击事件
            const inventoryModalBody = document.querySelector('#inventory-modal .modal-body');
            if (inventoryModalBody) {
              inventoryModalBody.addEventListener('click', e => {
                if (e.target.classList.contains('item-equip-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  // 新增：处理功法装备按钮
                  if (e.target.dataset.equipType === 'zhuxiu') {
                    this.equipItem(itemData, category, e.target, 'zhuxiuGongfa');
                  } else if (e.target.dataset.equipType === 'fuxiu') {
                    this.equipItem(itemData, category, e.target, 'fuxiuXinfa');
                  } else {
                    this.equipItem(itemData, category, e.target);
                  }
                } else if (e.target.classList.contains('item-use-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  this.useItem(itemData, e.target);
                } else if (e.target.classList.contains('item-unequip-btn')) {
                  const slotId = e.target.dataset.slotId;
                  const slotElement = document.getElementById(slotId);
                  if (slotElement) {
                    this.unequipItem(slotId, slotElement, true, true); // 从背包卸载，需要刷新背包UI
                  }
                } else if (e.target.classList.contains('item-discard-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  this.discardItem(itemData, category, itemElement);
                }
              });
            }

            // 事件委托：左侧装备面板的事件
            const characterPanel = document.querySelector('.character-panel');
            if (characterPanel) {
              // 悬浮显示Tooltip
              characterPanel.addEventListener('mouseover', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.showEquipmentTooltip(slot, e);
                }
              });
              characterPanel.addEventListener('mouseout', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot) {
                  this.hideEquipmentTooltip();
                }
              });
              // 点击卸载装备
              characterPanel.addEventListener('click', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.unequipItem(slot.id, slot, true, false); // 从主面板卸载，不需要弹出背包
                }
              });
            }

            // 为快速发送按钮绑定事件
            document.getElementById('btn-quick-send')?.addEventListener('click', () => this.executeQuickSend());

            // 新增：为“当前指令”按钮绑定事件
            document.getElementById('btn-quick-commands')?.addEventListener('click', e => {
              e.stopPropagation(); // 防止触发document的点击事件
              this.toggleQuickCommands();
            });

            // 新增：为指令列表项绑定事件（事件委托） - 已移除点击功能

            // 新增：点击外部关闭指令列表
            document.addEventListener('click', e => {
              const popup = document.getElementById('quick-command-popup');
              const button = document.getElementById('btn-quick-commands');
              if (popup && button && popup.style.display === 'block') {
                if (!popup.contains(e.target) && !button.contains(e.target)) {
                  this.hideQuickCommands();
                }
              }
            });
            this.listenersBound = true; // 设置标志位，确保此代码块只运行一次
          },
 
            // --- Modal Control ---
           async showGuixuSystem() {
            this.openModal('guixu-system-modal');
            const body = document.querySelector('#guixu-system-modal .modal-body');
            if (!body) return;
            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang kết nối đến Quy Khư...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              const stat_data = messages?.[0]?.data?.stat_data;
              if (!stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Không thể kết nối đến Quy Khư.</p>';
                return;
              }

              const currentLife = this.SafeGetValue(stat_data, 'Kiếp Thứ x Hiện Tại', '1');
              const guixuSpace = this.SafeGetValue(stat_data, 'Không Gian Quy Khư', 'Không có gì');
              const currentChoice = this.SafeGetValue(stat_data, 'Lựa Chọn Quy Khư Kiếp Này', 'Không');
              const chargeTime = this.SafeGetValue(stat_data, 'Thời Gian Nạp Quy Khư', '0');
              const shengli = this.SafeGetValue(stat_data, 'Tuổi Sinh Lý', 'N/A');
              const shengliMax = this.SafeGetValue(stat_data, 'Giới Hạn Tuổi Sinh Lý', 'N/A');
              const xinli = this.SafeGetValue(stat_data, 'Tuổi Tâm Lý', 'N/A');
              const xinliMax = this.SafeGetValue(stat_data, 'Giới Hạn Tuổi Tâm Lý', 'N/A');

              body.innerHTML = `
                    <div class="panel-section">
                        <div class="attributes-list">
                            <div class="attribute-item"><span class="attribute-name">Số kiếp hiện tại</span><span class="attribute-value">Kiếp thứ ${currentLife}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Tuổi Sinh Lý</span><span class="attribute-value">${shengli} / ${shengliMax}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Tuổi Tâm Lý</span><span class="attribute-value">${xinli} / ${xinliMax}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Không Gian Quy Khư</span><span class="attribute-value">${guixuSpace}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Lựa chọn kiếp này</span><span class="attribute-value">${currentChoice}</span></div>
                            <div class="attribute-item" style="margin-top: 15px;"><span class="attribute-name">Quy Khư Nạp Năng</span><span class="attribute-value">${chargeTime}%</span></div>
                            <div class="details-progress-bar">
                                <div class="details-progress-fill" style="width: ${chargeTime}%; background: linear-gradient(90deg, #dc143c, #ff6b6b, #ffd700);"></div>
                            </div>
                        </div>
                    </div>
                    <div style="padding: 20px 10px; text-align: center;">
                         <button id="btn-trigger-guixu" class="interaction-btn primary-btn" style="width: 80%; padding: 12px; font-size: 16px;">QUY KHƯ</button>
                    </div>
                `;

              // 为动态添加的按钮绑定事件
              document.getElementById('btn-trigger-guixu').addEventListener('click', () => {
                if (chargeTime >= 100) {
                  this.showCustomConfirm('Ngươi có chắc muốn bắt đầu vòng luân hồi tiếp theo không? Tất cả ký ức chưa được lưu trữ sẽ tan biến.', async () => {
                    try {
                      const command = '{{user}} lựa chọn Quy Khư, thế giới sẽ trở về điểm neo ban đầu';
                      await this.handleAction(command); // Changed to call handleAction
                      this.showTemporaryMessage('Luân hồi đã bắt đầu...');
                      this.closeAllModals();
                    } catch (error) {
                      console.error('Lỗi khi thực hiện lệnh Quy Khư:', error);
                      this.showTemporaryMessage('Thực hiện lệnh Quy Khư thất bại!');
                    }
                  });
                } else {
                  this.showTemporaryMessage('Tiến độ nạp năng Quy Khư chưa đủ');
                }
              });
            } catch (error) {
              console.error('Lỗi khi tải hệ thống Quy Khư:', error);
              body.innerHTML =
                '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi tải dữ liệu.</p>';
            }
          },

          async showCharacterDetails() {
            this.openModal('character-details-modal');
            const body = document.querySelector('#character-details-modal .modal-body');
            if (!body) return;
            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang tải dữ liệu nhân vật...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              const stat_data = messages?.[0]?.data?.stat_data;
              if (!stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Không thể tải dữ liệu nhân vật.</p>';
                return;
              }

              // 确保 this.baseAttributes 和装备加成是最新的
              this.updateDisplayedAttributes();

              // 从已渲染的左侧面板获取值，确保与显示一致
              const fali = document.getElementById('attr-fali').innerText;
              const shenhai = document.getElementById('attr-shenhai').innerText;
              const daoxin = document.getElementById('attr-daoxin').innerText;
              const kongsu = document.getElementById('attr-kongsu').innerText;
              const qiyun = document.getElementById('attr-qiyun').innerText;
              const shengli = document.getElementById('attr-shengli').innerText;
              const xinli = document.getElementById('attr-xinli').innerText;

              // 从 stat_data 获取新增的值
              const xiuxingjindu = this.SafeGetValue(stat_data, 'Tiến Độ Tu Vi', '0');
              const xiuxingpingjing = this.SafeGetValue(stat_data, 'Bình Cảnh Tu Vi', 'Không');

              // 构建HTML
              body.innerHTML = `
                    <div class="panel-section">
                        <div class="section-title">Thuộc Tính Cốt Lõi <span style="font-size: 10px; color: #8b7355;">(Hiện tại/Giới hạn)</span></div>
                        <div class="attributes-list">
                            <div class="attribute-item"><span class="attribute-name">Pháp Lực</span><span class="attribute-value">${fali}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Thần Hải</span><span class="attribute-value">${shenhai}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Đạo Tâm</span><span class="attribute-value">${daoxin}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Không Tốc</span><span class="attribute-value">${kongsu}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Khí Vận</span><span class="attribute-value">${qiyun}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Tuổi Sinh Lý</span><span class="attribute-value">${shengli}</span></div>
                            <div class="attribute-item"><span class="attribute-name">Tuổi Tâm Lý</span><span class="attribute-value">${xinli}</span></div>
                        </div>
                    </div>
                    <div class="panel-section">
                        <div class="section-title">Chi Tiết Tu Vi</div>
                        <div class="attributes-list">
                            <div class="attribute-item">
                                <span class="attribute-name">Tiến Độ Tu Vi</span>
                                <span class="attribute-value">${xiuxingjindu}%</span>
                            </div>
                            <div class="details-progress-bar">
                                <div class="details-progress-fill" style="width: ${xiuxingjindu}%;"></div>
                            </div>
                            <div class="attribute-item" style="margin-top: 8px;">
                                <span class="attribute-name">Bình Cảnh Hiện Tại</span>
                                <span class="attribute-value">${xiuxingpingjing}</span>
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
              console.error('Lỗi khi tải chi tiết nhân vật:', error);
              body.innerHTML =
                '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi tải dữ liệu.</p>';
            }
          },

          openModal(modalId) {
            this.closeAllModals();
            const modal = document.getElementById(modalId);
            if (modal) modal.style.display = 'flex';
          },

          closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
              modal.style.display = 'none';
            });
          },

          showCustomConfirm(message, onConfirm) {
            const modal = document.getElementById('custom-confirm-modal');
            const messageEl = document.getElementById('custom-confirm-message');
            const okBtn = document.getElementById('custom-confirm-btn-ok');
            const cancelBtn = document.getElementById('custom-confirm-btn-cancel');

            if (!modal || !messageEl || !okBtn || !cancelBtn) return;

            messageEl.textContent = message;

            // 使用 .cloneNode(true) 来移除旧的事件监听器
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            newOkBtn.addEventListener('click', () => {
              this.closeAllModals();
              if (typeof onConfirm === 'function') {
                onConfirm();
              }
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeAllModals();
            });

            this.openModal('custom-confirm-modal');
          },

          // --- Feature Implementations (now simplified) ---
          async showInventory() {
            this.openModal('inventory-modal');
            const body = document.querySelector('#inventory-modal .modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang kiểm kê hành trang...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Không thể lấy dữ liệu túi đồ.</p>';
                console.warn('Không thể tải stat_data từ tin nhắn hiện tại cho túi đồ.');
                return;
              }
              const stat_data = messages[0].data.stat_data;
              body.innerHTML = this.renderInventory(stat_data || {});
            } catch (error) {
              console.error('Lỗi khi tải túi đồ:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi tải túi đồ: ${error.message}</p>`;
            }
          },

          async showRelationships() {
            this.openModal('relationships-modal');
            const body = document.querySelector('#relationships-modal .modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang sắp xếp lại các mối nhân duyên...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Không thể lấy dữ liệu quan hệ nhân vật.</p>';
                return;
              }
              const stat_data = messages[0].data.stat_data;
              let relationships = stat_data['Danh Sách Quan Hệ Nhân Vật']?.[0];

              // **关键修复**: 处理从mvu加载的数据可能是字符串化JSON的情况
              if (typeof relationships === 'string') {
                try {
                  relationships = JSON.parse(relationships);
                } catch (e) {
                  console.error('Phân tích chuỗi danh sách quan hệ nhân vật thất bại:', e);
                  relationships = []; // Treat as an empty array on parse failure
                }
              }

              body.innerHTML = this.renderRelationships(relationships || []);
            } catch (error) {
              console.error('Lỗi khi tải quan hệ nhân vật:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi tải quan hệ nhân vật: ${error.message}</p>`;
            }
          },

          renderRelationships(relationships) {
            if (
              !Array.isArray(relationships) ||
              relationships.length === 0 ||
              relationships[0] === '$__META_EXTENSIBLE__$'
            ) {
              return '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Hồng trần thế tục, tạm thời không vướng bận.</p>';
            }

            let html = '';
            relationships.forEach(rawRel => {
              try {
                const rel = typeof rawRel === 'string' ? JSON.parse(rawRel) : rawRel;

                const name = this.SafeGetValue(rel, 'name', 'Người vô danh');
                const tier = this.SafeGetValue(rel, 'tier', 'Phàm nhân');
                const level = this.SafeGetValue(rel, 'Cấp Độ', '');
                const relationship = this.SafeGetValue(rel, 'relationship', 'Bèo nước gặp nhau');
                const description = this.SafeGetValue(rel, 'description', 'Thân thế không rõ');
                const favorability = parseInt(this.SafeGetValue(rel, 'favorability', 0), 10);
                const eventHistory = rel.event_history || [];

                const tierStyle = this.getTierStyle(tier);
                const favorabilityPercent = Math.max(0, Math.min(100, (favorability / 200) * 100)); // 假设好感度上限为200
                const cultivationDisplay = level ? `${tier} ${level}` : tier;

                html += `
                            <div class="relationship-card">
                                <div class="relationship-body">
                                    <p class="relationship-name" style="${tierStyle}">${name}</p>
                                    <p>${description}</p>
                                    
                                    <div class="relationship-meta">
                                        <span>Quan hệ: ${relationship}</span>
                                        <span>Tu vi: <span style="${tierStyle}">${cultivationDisplay}</span></span>
                                    </div>

                                    <p style="margin-top: 10px;">Thiện cảm: ${favorability}</p>
                                    <div class="favorability-bar-container">
                                        <div class="favorability-bar-fill" style="width: ${favorabilityPercent}%;"></div>
                                    </div>

                                    ${
                                      Array.isArray(eventHistory) && eventHistory.length > 0
                                        ? `
                                    <details class="event-history-details">
                                        <summary class="event-history-summary">Từng giao hảo</summary>
                                        <ul class="event-history-list">
                                            ${eventHistory.filter(event => event !== '$__META_EXTENSIBLE__$' && event !== '...').map(event => `<li>${event}</li>`).join('')}
                                        </ul>
                                    </details>
                                    `
                                        : ''
                                    }
                                </div>
                            </div>
                        `;
              } catch (e) {
                console.error('Phân tích quan hệ nhân vật thất bại:', rawRel, e);
              }
            });

            return (
              html ||
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Hồng trần thế tục, tạm thời không vướng bận.</p>'
            );
          },

          getTierStyle(tier) {
            const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; animation: god-tier-animation 3s linear infinite; font-weight: bold;';
            const styles = {
              'Luyện Khí': 'color: #FFFFFF;',
              'Trúc Cơ': 'color: #66CDAA;',
              'Kim Đan': 'color: #FFD700;',
              'Nguyên Anh': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle}`,
              'Hóa Thần': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle}`,
              'Hợp Thể': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle}`,
              'Phi Thăng': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle}`,
              'Thần Kiều': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle}`,
            };
            const baseStyle = 'font-style: italic;';
            return (styles[tier] || 'color: #e0dcd1;') + baseStyle;
          },

          // --- 新增：品阶排序核心函数 ---
          getTierOrder(tier) {
            // Tier level mapping: higher value means higher tier
            // Supports two tier systems:
            // 1. Item Tiers: Thần Phẩm > Tiên Phẩm > Thiên Phẩm > Cực Phẩm > Thượng Phẩm > Trung Phẩm > Hạ Phẩm > Phàm Phẩm
            // 2. Cultivation Realms: Thần Kiều > Phi Thăng > Hợp Thể > Hóa Thần > Nguyên Anh > Kim Đan > Trúc Cơ > Luyện Khí
            const tierOrder = {
              // 物品品阶系统
              'Phàm Phẩm': 1,
              'Hạ Phẩm': 2,
              'Trung Phẩm': 3,
              'Thượng Phẩm': 4,
              'Cực Phẩm': 5,
              'Thiên Phẩm': 6,
              'Tiên Phẩm': 7,
              'Thần Phẩm': 8,
              
              // 修仙境界系统
              'Trúc Cơ': 2,
              'Kim Đan': 3,
              'Nguyên Anh': 4,
              'Hóa Thần': 5,
              'Hợp Thể': 6,
              'Phi Thăng': 7,
              'Thần Kiều': 8
            };
            return tierOrder[tier] || 0; // 未知品阶排在最前
          },

          // --- 新增：通用品阶排序函数 ---
          sortByTier(items, getTierFn) {
            if (!Array.isArray(items)) return items;
            
            return [...items].sort((a, b) => {
              const tierA = getTierFn(a);
              const tierB = getTierFn(b);
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              
              // 按品阶从高到低排序，支持两种品阶系统：
              // Item Tiers: Thần Phẩm > Tiên Phẩm > ... > Phàm Phẩm
              // Cultivation Realms: Thần Kiều > Phi Thăng > ... > Luyện Khí
              // 如果品阶相同，则保持原有顺序（稳定排序）
              if (orderA === orderB) {
                return 0;
              }
              return orderB - orderA;
            });
          },

          getTierColorStyle(tier) {
            const tierColors = {
              'Phàm Phẩm': '#FFFFFF',
              'Hạ Phẩm': '#66CDAA',
              'Trung Phẩm': '#FFD700',
              'Thượng Phẩm': 'linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6)',
              'Cực Phẩm': 'linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C)',
              'Thiên Phẩm': 'linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585)',
              'Tiên Phẩm': 'linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C)',
              'Thần Phẩm': 'linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc)',
            };

            const animatedTiers = ['Thượng Phẩm', 'Cực Phẩm', 'Thiên Phẩm', 'Tiên Phẩm', 'Thần Phẩm'];
            const color = tierColors[tier] || '#e0dcd1';

            if (animatedTiers.includes(tier)) {
              return `background: ${color}; background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; animation: god-tier-animation 3s linear infinite; font-weight: bold;`;
            }

            return `color: ${color};`;
          },

          updateTalentAndLinggen(data) {
            const container = document.getElementById('talent-linggen-list');
            if (!container) return;
            container.innerHTML = '';

            let html = '';

            // 1. 处理灵根列表 - 添加品阶排序
            const linggenList = _.get(data, 'Danh Sách Linh Căn.0', []);
            if (Array.isArray(linggenList) && linggenList.length > 0 && linggenList[0] !== '$__META_EXTENSIBLE__$') {
              // 解析并排序灵根
              const parsedLinggenList = [];
              linggenList.forEach(rawLinggen => {
                try {
                  const linggen = typeof rawLinggen === 'string' ? JSON.parse(rawLinggen) : rawLinggen;
                  if (linggen && typeof linggen === 'object') {
                    parsedLinggenList.push(linggen);
                  }
                } catch (e) {
                  console.error('Phân tích Linh Căn thất bại:', rawLinggen, e);
                }
              });

              // Sort Linh Căn by tier (Thần Phẩm > Tiên Phẩm > ... > Phàm Phẩm)
              const sortedLinggenList = this.sortByTier(parsedLinggenList, (linggen) =>
                this.SafeGetValue(linggen, 'Phẩm Giai', 'Phàm Phẩm')
              );

              sortedLinggenList.forEach(linggen => {
                const name = this.SafeGetValue(linggen, 'Tên', 'Linh Căn không rõ');
                const tier = this.SafeGetValue(linggen, 'Phẩm Giai', 'Phàm Phẩm');
                const description = this.SafeGetValue(linggen, 'Mô tả', 'Không có mô tả');
                const tierStyle = this.getTierColorStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(linggen);

                html += `
                     <details class="details-container">
                         <summary>
                             <span class="attribute-name">Linh Căn</span>
                             <span class="attribute-value" style="${tierStyle}">【${tier}】 ${name}</span>
                         </summary>
                         <div class="details-content">
                             <p>${description}</p>
                             ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                         </div>
                     </details>
                 `;
              });
            } else {
                 html += `
                   <div class="attribute-item">
                       <span class="attribute-name">Linh Căn</span>
                       <span class="attribute-value">Chưa thức tỉnh</span>
                   </div>
               `;
            }

            // 2. 处理天赋列表 - 添加品阶排序
            const tianfuList = _.get(data, 'Danh Sách Thiên Phú.0', []);
            if (Array.isArray(tianfuList) && tianfuList.length > 0 && tianfuList[0] !== '$__META_EXTENSIBLE__$') {
              // 解析并排序天赋
              const parsedTianfuList = [];
              tianfuList.forEach(rawTianfu => {
                try {
                  const tianfu = typeof rawTianfu === 'string' ? JSON.parse(rawTianfu) : rawTianfu;
                  if (tianfu && typeof tianfu === 'object') {
                    parsedTianfuList.push(tianfu);
                  }
                } catch (e) {
                  console.error('Phân tích Thiên Phú thất bại:', rawTianfu, e);
                }
              });

              // Sort Thiên Phú by tier (Thần Phẩm > Tiên Phẩm > ... > Phàm Phẩm)
              const sortedTianfuList = this.sortByTier(parsedTianfuList, (tianfu) =>
                this.SafeGetValue(tianfu, 'tier', 'Phàm Phẩm')
              );

              sortedTianfuList.forEach(tianfu => {
                const name = this.SafeGetValue(tianfu, 'name', 'Thiên Phú không rõ');
                const tier = this.SafeGetValue(tianfu, 'tier', 'Phàm Phẩm');
                const description = this.SafeGetValue(tianfu, 'description', 'Không có mô tả');
                const tierStyle = this.getTierColorStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(tianfu);

                html += `
                         <details class="details-container">
                             <summary>
                                 <span class="attribute-name">Thiên Phú</span>
                                 <span class="attribute-value" style="${tierStyle}">【${tier}】 ${name}</span>
                             </summary>
                             <div class="details-content">
                                 <p>${description}</p>
                                 ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                             </div>
                         </details>
                     `;
              });
            } else {
              html += `
                   <div class="attribute-item">
                       <span class="attribute-name">Thiên Phú</span>
                       <span class="attribute-value">Chưa thức tỉnh</span>
                   </div>
               `;
            }

            container.innerHTML = html;
          },

          renderInventory(stat_data) {
            if (!stat_data || Object.keys(stat_data).length === 0) {
              return '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Dữ liệu túi đồ trống.</p>';
            }

            const categories = [
              { title: 'Công Pháp', key: 'Danh Sách Công Pháp', equipable: true },
              { title: 'Vũ Khí', key: 'Danh Sách Vũ Khí', equipable: true },
              { title: 'Phòng Cụ', key: 'Danh Sách Phòng Cụ', equipable: true },
              { title: 'Phụ Kiện', key: 'Danh Sách Phụ Kiện', equipable: true },
              { title: 'Pháp Bảo', key: 'Danh Sách Pháp Bảo', equipable: true },
              { title: 'Đan Dược', key: 'Danh Sách Đan Dược', equipable: false },
              { title: 'Tạp Vật', key: 'Danh Sách Khác', equipable: false },
            ];

            let html = '';

            categories.forEach(cat => {
              const rawItems = stat_data?.[cat.key]?.[0];

              html += `<details class="inventory-category" open>`;
              html += `<summary class="inventory-category-title">${cat.title}</summary>`;

              if (Array.isArray(rawItems) && rawItems.length > 0 && rawItems[0] !== '$__META_EXTENSIBLE__$') {
                html += '<div class="inventory-item-list">';
                
                // --- 新增：解析并按品阶排序物品 ---
                const parsedItems = [];
                rawItems.forEach(rawItem => {
                  try {
                    // **关键修复**: 在处理前检查 rawItem 是否为 null 或 undefined
                    if (!rawItem) {
                        console.warn(`Phát hiện một mục vật phẩm trống trong danh mục "${cat.title}", đã bỏ qua.`);
                        return; // 跳过这个无效的条目
                    }
                    const item = typeof rawItem === 'string' ? JSON.parse(rawItem) : rawItem;
                    if (item && typeof item === 'object') {
                      parsedItems.push(item);
                    }
                  } catch (e) {
                    console.error('Phân tích vật phẩm trong túi đồ thất bại:', rawItem, e);
                  }
                });

                // Sort items by tier (Thần Phẩm > Tiên Phẩm > ... > Phàm Phẩm)
                const sortedItems = this.sortByTier(parsedItems, (item) =>
                  this.SafeGetValue(item, 'tier', 'Phàm Phẩm')
                );

                sortedItems.forEach(item => {
                  try {
                    // 确保传递给前端的数据是完整的
                    const itemJson = JSON.stringify(item).replace(/'/g, "'");

                    const name = this.SafeGetValue(item, 'name', 'Vật phẩm không rõ');
                    const id = this.SafeGetValue(item, 'id', null);
                    const tier = this.SafeGetValue(item, 'tier', 'Không');
                    const hasQuantity = item.hasOwnProperty('quantity');
                    const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                    const description = this.SafeGetValue(
                      item,
                      'description',
                      this.SafeGetValue(item, 'effect', 'Không có mô tả'),
                    );

                    // **BUG修复**: 计算显示数量时，减去待处理队列中的使用和丢弃数量
                    const pendingUses = this.pendingActions
                      .filter(action => action.action === 'use' && action.itemName === name)
                      .reduce((total, action) => total + action.quantity, 0);
                    const pendingDiscards = this.pendingActions
                      .filter(action => action.action === 'discard' && action.itemName === name)
                      .reduce((total, action) => total + action.quantity, 0);
                    const displayQuantity = quantity - pendingUses - pendingDiscards;

                    // 如果物品数量为0或负数，跳过渲染（实现前端乐观隐藏）
                    if (hasQuantity && displayQuantity <= 0) {
                      return; // 跳过这个物品的渲染
                    }

                    // 对于装备类物品，如果在待丢弃队列中，也跳过渲染
                    if (!hasQuantity && pendingDiscards > 0) {
                      return; // 跳过这个物品的渲染
                    }

                    const tierStyle = this.getTierStyle(tier);
                    const tierDisplay =
                      tier !== 'Không' ? `<span style="${tierStyle} margin-right: 15px;">Phẩm Giai: ${tier}</span>` : '';
                    const quantityDisplay = hasQuantity ? `<span class="item-quantity">Số lượng: ${displayQuantity}</span>` : '';

                    // **关键修复**: 检查物品是否已被装备
                    const isEquipped = id ? Object.values(this.equippedItems).some(equippedItem => equippedItem && equippedItem.id === id) : false;
                    let actionButton = '';

                    if (cat.title === 'Công Pháp') {
                      const isEquippedAsMain =
                        id && this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.id === id;
                      const isEquippedAsAux =
                        id && this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.id === id;

                      if (isEquippedAsMain) {
                        actionButton = `
                                <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">Tháo</button>
                                <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>Phụ Tu</button>
                            `;
                      } else if (isEquippedAsAux) {
                        actionButton = `
                                <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>Chủ Tu</button>
                                <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">Tháo</button>
                            `;
                      } else {
                        actionButton = `
                                <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">Chủ Tu</button>
                                <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">Phụ Tu</button>
                            `;
                      }
                    } else if (cat.equipable) {
                      if (isEquipped) {
                        const slotKey = Object.keys(this.equippedItems).find(
                          key => this.equippedItems[key] && this.equippedItems[key].id === id,
                        );
                        actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">Tháo</button>`;
                      } else {
                        actionButton = `<button class="item-equip-btn">Trang bị</button>`;
                      }
                    } else if (cat.title === 'Đan Dược' || cat.title === 'Tạp Vật') {
                      if (displayQuantity <= 0) {
                          actionButton = `<button class="item-use-btn" disabled>Đã hết</button>`;
                      } else {
                          actionButton = `<button class="item-use-btn">Dùng</button>`;
                      }
                    }

                    // 为所有物品添加丢弃按钮
                    if (cat.title === 'Đan Dược' || cat.title === 'Tạp Vật') {
                      // 有数量的物品，需要输入数量
                      actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">Vứt</button>`;
                    } else {
                      // 装备类物品，直接丢弃
                      actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">Vứt</button>`;
                    }

                    let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                    html += `
                                    <div class="inventory-item" data-item-details='${itemJson}' data-category='${
                      cat.title
                    }'>
                                        <div class="item-header">
                                            <div class="item-name-desc">
                                                <span class="item-name" style="${tierStyle}">${name}</span>
                                                <div class="item-description">${description}</div>
                                            </div>
                                            <div class="item-meta" style="text-align: right; white-space: nowrap; display: flex; align-items: center;">
                                                ${tierDisplay}
                                                ${quantityDisplay}
                                                ${actionButton}
                                            </div>
                                        </div>
                                        ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                                    </div>
                                `;
                  } catch (e) {
                    console.error('Phân tích vật phẩm trong túi đồ thất bại:', item, e);
                    html += `<div class="inventory-item"><p class="item-description">Định dạng dữ liệu vật phẩm bị lỗi</p></div>`;
                  }
                });
                html += '</div>';
              } else {
                html += '<div class="inventory-item-list"><p class="empty-category-text">Trống rỗng</p></div>';
              }
              html += `</details>`;
            });

            return html;
          },

          // --- Tooltip and Equip Logic (重构后) ---
          renderTooltipContent(item) {
            // 根据最新的变量结构解析
            const tierStyle = this.getTierStyle(this.SafeGetValue(item, 'tier'));
            const level = this.SafeGetValue(item, 'level', '');
            const tierDisplay = level
              ? `${this.SafeGetValue(item, 'tier', 'Phàm Phẩm')} ${level}`
              : this.SafeGetValue(item, 'tier', 'Phàm Phẩm');

            let attributesHtml = '';
            const attributes = item.attributes_bonus; // 直接使用新key
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += `<div class="tooltip-section-title">Cộng thêm cố định</div>`;
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['Phần trăm gia tăng'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">Phần trăm gia tăng</div>`;
              for (const [key, value] of Object.entries(percentBonuses)) {
                 attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`;
              }
            }

            let effectsHtml = '';
            const effects = item.special_effects; // 直接使用新key
            if (Array.isArray(effects) && effects.length > 0) {
              effectsHtml += `<div class="tooltip-section-title">Thuộc tính đặc biệt</div>`;
              effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join('');
            }

            return `
                    <div class="tooltip-title" style="${tierStyle}">${this.SafeGetValue(item, 'name')}</div>
                    <p><strong>Phẩm Giai:</strong> ${tierDisplay}</p>
                    <p><i>${this.SafeGetValue(item, 'description', 'Không có mô tả')}</i></p>
                    ${
                      attributesHtml
                        ? `<div class="tooltip-section tooltip-attributes">${attributesHtml}</div>`
                        : ''
                    }
                    ${effectsHtml ? `<div class="tooltip-section">${effectsHtml}</div>` : ''}
                `;
          },

          showEquipmentTooltip(element, event) {
            const tooltip = document.getElementById('equipment-tooltip');
            const itemDataString = element.dataset.itemDetails;
            if (!tooltip || !itemDataString) return;

            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              tooltip.innerHTML = this.renderTooltipContent(item);
              tooltip.style.display = 'block';

              // **关键修复**: 调整Tooltip位置以防止超出视口
              const tooltipRect = tooltip.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;

              let left = event.pageX + 15;
              let top = event.pageY + 15;

              // 如果Tooltip超出右边界，则显示在鼠标左侧
              if (left + tooltipRect.width > viewportWidth) {
                left = event.pageX - tooltipRect.width - 15;
              }

              // 如果Tooltip超出下边界，则显示在鼠标上侧
              if (top + tooltipRect.height > viewportHeight) {
                top = event.pageY - tooltipRect.height - 15;
              }

              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } catch (e) {
              console.error('Phân tích dữ liệu tooltip trang bị thất bại:', e);
            }
          },

          hideEquipmentTooltip() {
            const tooltip = document.getElementById('equipment-tooltip');
            if (tooltip) tooltip.style.display = 'none';
          },

          renderItemDetailsForInventory(item) {
            let attributesHtml = '';
            const attributes = item.attributes_bonus;
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">Cộng thêm cố định</div>';
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['Phần trăm gia tăng'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">Phần trăm gia tăng</div>';
              for (const [key, value] of Object.entries(percentBonuses)) {
                 attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`;
              }
            }

            let effectsHtml = '';
            let effects = item.special_effects;

            // 关键修复：处理 special_effects 可能是字符串（用\n分隔）或数组两种情况
            if (typeof effects === 'string' && effects.trim() !== '') {
                effects = effects.split('\n').map(e => e.trim()).filter(e => e);
            }

            if (Array.isArray(effects) && effects.length > 0) {
              effectsHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">Thuộc tính đặc biệt</div>`;
              effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join('');
            }

            return `${attributesHtml}${effectsHtml}`;
          },

          equipItem(item, category, buttonElement, equipType = null) {
            const itemId = this.SafeGetValue(item, 'id');
            if (!itemId || itemId === 'N/A') {
              this.showTemporaryMessage('Vật phẩm không có ID, không thể trang bị.');
              return;
            }

            // Bug修复：检查功法是否已被装备在另一个槽位
            if (category === 'Công Pháp') {
              const isEquippedAsMain = this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.id === itemId;
              const isEquippedAsAux = this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.id === itemId;

              if (
                (equipType === 'fuxiuXinfa' && isEquippedAsMain) ||
                (equipType === 'zhuxiuGongfa' && isEquippedAsAux)
              ) {
                this.showTemporaryMessage('Công pháp này đã được trang bị ở ô khác.');
                return;
              }
            }

            const categoryMap = { 'Vũ Khí': 'wuqi', 'Phòng Cụ': 'fangju', 'Phụ Kiện': 'shipin', 'Pháp Bảo': 'fabao1', 'Công Pháp': equipType };
            const slotKey = categoryMap[category];

            if (!slotKey) {
              this.showTemporaryMessage('Phân loại hoặc loại trang bị không hợp lệ.');
              return;
            }

            // **关键修复**: 检查物品是否已装备在其他槽位，如果是，则先卸载
            const currentlyEquippedSlot = Object.keys(this.equippedItems).find(
              key => this.equippedItems[key] && this.equippedItems[key].id === itemId,
            );
            if (currentlyEquippedSlot && currentlyEquippedSlot !== slotKey) {
              const oldSlotElement = document.getElementById(`equip-${currentlyEquippedSlot}`);
              if (oldSlotElement) {
                this.unequipItem(`equip-${currentlyEquippedSlot}`, oldSlotElement, false); // 静默卸载
              }
            }

            const slotElement = document.getElementById(`equip-${slotKey}`);
            if (!slotElement) return;

            // 如果该槽位已有装备，先执行卸载操作
            const oldItemId = this.equippedItems[slotKey];
            if (oldItemId) {
              this.unequipItem(`equip-${slotKey}`, slotElement, false);
            }

            // 更新前端状态和UI（乐观更新）
            this.equippedItems[slotKey] = item; // **逻辑修正**: 存储完整对象
            const tier = this.SafeGetValue(item, 'tier', 'Phàm Phẩm');
            const tierStyle = this.getTierStyle(tier);
            slotElement.textContent = this.SafeGetValue(item, 'name');
            slotElement.setAttribute('style', tierStyle);
            slotElement.classList.add('equipped');
            slotElement.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");

            // 更新背包UI，使其能反映最新状态
            if (buttonElement.closest('#inventory-modal')) {
              this.showInventory();
            }

            // 添加到指令队列（优化：先移除旧指令，再添加新指令）
            const itemName = this.SafeGetValue(item, 'name');
            const defaultTextMap = {
              wuqi: 'Vũ Khí',
              fangju: 'Phòng Cụ',
              shipin: 'Phụ Kiện',
              fabao1: 'Pháp Bảo',
              zhuxiuGongfa: 'Công Pháp Chủ Tu',
              fuxiuXinfa: 'Tâm Pháp Phụ Tu',
            };
            const slotFriendlyName = defaultTextMap[slotKey] || category;
            this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName);
            this.pendingActions.push({
              action: 'equip',
              itemName: itemName,
              category: slotFriendlyName,
            });

            this.showTemporaryMessage(`Đã trang bị ${this.SafeGetValue(item, 'name')}`);
            this.updateDisplayedAttributes();
            this.saveEquipmentState(); // 保存状态
            this.savePendingActions(); // 保存指令状态
          },

          unequipItem(slotId, slotElement, showMessage = true, refreshInventoryUI = true) {
            const slotKey = slotId.replace('equip-', '');
            const defaultTextMap = {
              wuqi: 'Vũ Khí',
              fangju: 'Phòng Cụ',
              shipin: 'Phụ Kiện',
              fabao1: 'Pháp Bảo',
              zhuxiuGongfa: 'Công Pháp Chủ Tu',
              fuxiuXinfa: 'Tâm Pháp Phụ Tu',
            };

            const itemDataString = slotElement.dataset.itemDetails;
            if (!itemDataString) return; // 如果没有物品，则不执行任何操作

            let itemName = 'một trang bị';
            let itemId = null;
            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              itemName = this.SafeGetValue(item, 'name');
              itemId = this.SafeGetValue(item, 'id');
            } catch (e) {
              console.error('Phân tích dữ liệu vật phẩm khi tháo thất bại', e);
            }

            // 清理前端状态和UI
            this.equippedItems[slotKey] = null;
            slotElement.textContent = defaultTextMap[slotKey] || 'Trống';
            slotElement.classList.remove('equipped');
            slotElement.removeAttribute('style');
            delete slotElement.dataset.itemDetails;

            // **关键修复**: 不再进行复杂的局部DOM更新，而是直接重新渲染整个背包以确保UI同步
            if (refreshInventoryUI) {
              this.showInventory();
            }

            // 添加到指令队列（优化：先移除旧指令，再添加新指令）
            this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName);
            this.pendingActions.push({
              action: 'unequip',
              itemName: itemName,
              category: defaultTextMap[slotKey],
            });

            if (showMessage) {
              this.showTemporaryMessage(`Đã tháo ${itemName}`);
            }
            this.updateDisplayedAttributes();
            this.saveEquipmentState(); // 保存状态
            this.savePendingActions(); // 保存指令状态
            // 注意：showInventory() 已经包含了关闭模态框再打开的过程，所以UI会刷新
          },

          loadEquipmentFromMVU(data) {
            const equipmentMap = {
              'Vũ Khí': 'wuqi',
              'Công Pháp Chủ Tu': 'zhuxiuGongfa',
              'Tâm Pháp Phụ Tu': 'fuxiuXinfa',
              'Phòng Cụ': 'fangju',
              'Phụ Kiện': 'shipin',
              'Ô Pháp Bảo 1': 'fabao1',
            };
            const defaultTextMap = {
              wuqi: 'Vũ Khí',
              fangju: 'Phòng Cụ',
              shipin: 'Phụ Kiện',
              fabao1: 'Pháp Bảo',
              zhuxiuGongfa: 'Công Pháp Chủ Tu',
              fuxiuXinfa: 'Tâm Pháp Phụ Tu',
            };

            for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
              const slot = document.getElementById(`equip-${slotKey}`);
              if (!slot) continue;

              // mvu中的装备数据通常是 [ { item_object } ] 的形式
              // **局部修复**: 直接使用 _.get 获取装备数组，避免 SafeGetValue 将其错误地转为字符串
              const itemArray = _.get(data, mvuKey, null);
              const item = Array.isArray(itemArray) && itemArray.length > 0 ? itemArray[0] : null;

              if (item && typeof item === 'object') {
                const tier = this.SafeGetValue(item, 'tier', 'Phàm Phẩm');
                const tierStyle = this.getTierStyle(tier);
                // **逻辑修正**: 此处不再主动修改 this.equippedItems
                // this.equippedItems 的状态由 localStorage 和 equip/unequip 动作管理
                // this.equippedItems[slotKey] = item;
                slot.textContent = this.SafeGetValue(item, 'name');
                slot.setAttribute('style', tierStyle);
                slot.classList.add('equipped');
                slot.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");
              } else {
                // this.equippedItems[slotKey] = null; // **关键修复**: 此函数不应修改核心状态，只渲染从mvu得到的数据
                slot.textContent = defaultTextMap[slotKey];
                slot.classList.remove('equipped');
                slot.removeAttribute('style');
                delete slot.dataset.itemDetails;
              }
            }
          },

          updateDisplayedAttributes() {
            // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
            // 根据新的变量结构重写属性计算逻辑
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              console.warn('无法更新属性：mvu状态不可用。');
              return;
            }

            const stat_data = this.currentMvuState.stat_data;
            const baseAttrs = {
              fali: parseInt(this.SafeGetValue(stat_data, 'Pháp Lực Cơ Bản', 0), 10),
              shenhai: parseInt(this.SafeGetValue(stat_data, 'Thần Hải Cơ Bản', 0), 10),
              daoxin: parseInt(this.SafeGetValue(stat_data, 'Đạo Tâm Cơ Bản', 0), 10),
              kongsu: parseInt(this.SafeGetValue(stat_data, 'Không Tốc Cơ Bản', 0), 10),
              qiyun: parseInt(this.SafeGetValue(stat_data, 'Khí Vận Cơ Bản', 0), 10),
            };

            const totalFlatBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0 };
            const totalPercentBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0 };
            const attributeMapping = { 'Pháp Lực': 'fali', 'Thần Hải': 'shenhai', 'Đạo Tâm': 'daoxin', 'Không Tốc': 'kongsu', 'Khí Vận': 'qiyun' };

            const processBonuses = (item) => {
              if (!item || typeof item !== 'object') return;
              
              const flatBonuses = item.attributes_bonus;
              if (flatBonuses && typeof flatBonuses === 'object') {
                for (const [attrName, bonusValue] of Object.entries(flatBonuses)) {
                  const attrKey = attributeMapping[attrName];
                  if (attrKey) {
                    totalFlatBonuses[attrKey] += parseInt(bonusValue, 10) || 0;
                  }
                }
              }
              
              const percentBonuses = item['Phần trăm gia tăng'];
              if (percentBonuses && typeof percentBonuses === 'object') {
                 for (const [attrName, bonusValue] of Object.entries(percentBonuses)) {
                    const attrKey = attributeMapping[attrName];
                    if (attrKey) {
                        totalPercentBonuses[attrKey] += parseFloat(String(bonusValue).replace('%','')) / 100 || 0;
                    }
                }
              }
            };

            // 1. 收集所有加成来源
            Object.values(this.equippedItems).forEach(processBonuses);
            const tianfuList = _.get(stat_data, 'Danh Sách Thiên Phú.0', []);
            if (Array.isArray(tianfuList)) {
              tianfuList.forEach(tianfu => {
                if (typeof tianfu === 'object' && tianfu !== null) processBonuses(tianfu);
              });
            }
            // 修改：处理灵根列表而非单个灵根
            const linggenListData = _.get(stat_data, 'Danh Sách Linh Căn.0', []);
            if (Array.isArray(linggenListData)) {
              linggenListData.forEach(rawLinggen => {
                try {
                  if (!rawLinggen || rawLinggen === '$__META_EXTENSIBLE__$') return;
                  const linggen = typeof rawLinggen === 'string' ? JSON.parse(rawLinggen) : rawLinggen;
                  if (linggen && typeof linggen === 'object') {
                    processBonuses(linggen);
                  }
                } catch (e) {
                  console.error('Phân tích thất bại khi xử lý cộng thêm từ Linh Căn:', rawLinggen, e);
                }
              });
            }

            // 2. 计算最终上限: 上限 = (基础 + Σ固定) * (1 + Σ百分比)
            const calculatedMaxAttrs = {
              fali: Math.floor((baseAttrs.fali + totalFlatBonuses.fali) * (1 + totalPercentBonuses.fali)),
              shenhai: Math.floor((baseAttrs.shenhai + totalFlatBonuses.shenhai) * (1 + totalPercentBonuses.shenhai)),
              daoxin: Math.floor((baseAttrs.daoxin + totalFlatBonuses.daoxin) * (1 + totalPercentBonuses.daoxin)),
              kongsu: Math.floor((baseAttrs.kongsu + totalFlatBonuses.kongsu) * (1 + totalPercentBonuses.kongsu)),
              qiyun: Math.floor((baseAttrs.qiyun + totalFlatBonuses.qiyun) * (1 + totalPercentBonuses.qiyun)),
            };
            
            // 新增：缓存计算结果，供其他函数使用
            this.calculatedMaxAttributes = calculatedMaxAttrs;

            // 3. 获取当前值，并确保不超过新计算的上限
            const currentAttrs = {
                fali: Math.min(parseInt(this.SafeGetValue(stat_data, 'Pháp Lực Hiện Tại', 0), 10), calculatedMaxAttrs.fali),
                shenhai: Math.min(parseInt(this.SafeGetValue(stat_data, 'Thần Hải Hiện Tại', 0), 10), calculatedMaxAttrs.shenhai),
                daoxin: Math.min(parseInt(this.SafeGetValue(stat_data, 'Đạo Tâm Hiện Tại', 0), 10), calculatedMaxAttrs.daoxin),
                kongsu: Math.min(parseInt(this.SafeGetValue(stat_data, 'Không Tốc Hiện Tại', 0), 10), calculatedMaxAttrs.kongsu),
            };

            // 4. 更新UI
            document.getElementById('attr-fali').innerText = `${currentAttrs.fali} / ${calculatedMaxAttrs.fali}`;
            document.getElementById('attr-shenhai').innerText = `${currentAttrs.shenhai} / ${calculatedMaxAttrs.shenhai}`;
            document.getElementById('attr-daoxin').innerText = `${currentAttrs.daoxin} / ${calculatedMaxAttrs.daoxin}`;
            document.getElementById('attr-kongsu').innerText = `${currentAttrs.kongsu} / ${calculatedMaxAttrs.kongsu}`;
            document.getElementById('attr-qiyun').innerText = calculatedMaxAttrs.qiyun;
            
            // 年龄等非计算属性直接更新
            document.getElementById('attr-shengli').innerText = `${this.SafeGetValue(stat_data, 'Tuổi Sinh Lý')} / ${this.SafeGetValue(stat_data, 'Giới Hạn Tuổi Sinh Lý')}`;
            document.getElementById('attr-xinli').innerText = `${this.SafeGetValue(stat_data, 'Tuổi Tâm Lý')} / ${this.SafeGetValue(stat_data, 'Giới Hạn Tuổi Tâm Lý')}`;
          },

          showTemporaryMessage(message, duration = 2000) {
            const existingMsg = document.querySelector('.temp-message-popup');
            if (existingMsg) existingMsg.remove();

            const msgElement = document.createElement('div');
            msgElement.className = 'temp-message-popup';
            msgElement.textContent = message;
            msgElement.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(45, 27, 61, 0.9);
                    color: #c9aa71;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 2000;
                    font-size: 14px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                    text-align: center;
                    transition: opacity 0.5s ease-out;
                `;
            document.querySelector('.guixu-root-container').appendChild(msgElement);

            setTimeout(() => {
              msgElement.style.opacity = '0';
              setTimeout(() => msgElement.remove(), 500);
            }, duration - 500);
          },

          showCommandCenter() {
            this.openModal('command-center-modal');
            const body = document.querySelector('#command-center-modal .modal-body');
            if (!body) return;

            if (this.pendingActions.length === 0) {
              body.innerHTML =
                '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Chưa có mệnh lệnh nào chờ chấp hành.</p>';
              return;
            }

            let html = '<ul class="command-center-actions">';
            this.pendingActions.forEach(cmd => {
              let actionText = '';
              switch (cmd.action) {
                case 'equip':
                  actionText = `[Trang bị] ${cmd.itemName} vào ô ${cmd.category}`;
                  break;
                case 'unequip':
                  actionText = `[Tháo] ${cmd.itemName} từ ô ${cmd.category}`;
                  break;
                case 'use':
                  actionText = `[Dùng] ${cmd.itemName} x ${cmd.quantity}`;
                  break;
                case 'discard':
                  if (cmd.quantity && cmd.quantity > 1) {
                    actionText = `[Vứt] ${cmd.itemName} x ${cmd.quantity}`;
                  } else {
                    actionText = `[Vứt] ${cmd.itemName}`;
                  }
                  break;
              }
              html += `<li class="command-center-action-item">${actionText}</li>`;
            });
            html += '</ul>';
            body.innerHTML = html;
          },

          clearPendingActions() {
            this.pendingActions = [];
            this.showCommandCenter(); // 重新渲染指令中心以显示空状态
            this.showTemporaryMessage('Mệnh lệnh đã được xóa sạch');
            this.savePendingActions();
          },

          refreshLocalStorage() {
            this.showCustomConfirm('Thao tác này dùng để làm mới dữ liệu cache của cuộc trò chuyện trước. Nếu không phải mở cuộc trò chuyện mới, xin đừng bấm vào', () => {
              try {
                localStorage.removeItem('guixu_equipped_items');
                localStorage.removeItem('guixu_pending_actions');
                localStorage.removeItem('guixu_auto_write_enabled');
                this.showTemporaryMessage('Bộ nhớ đệm đã được xóa, trang sẽ sớm được làm mới...');
                setTimeout(() => {
                  window.location.reload();
                }, 1500);
              } catch (e) {
                console.error('Xóa bộ nhớ cục bộ thất bại:', e);
                this.showTemporaryMessage('Xóa bộ nhớ đệm thất bại!');
              }
            });
          },

          async executePendingActions() {
            // 指令中心执行时，不带用户输入
            await this.handleAction();
          },

          useItem(item, buttonElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('Thông tin vật phẩm bị lỗi, không thể sử dụng.');
              return;
            }

            // **BUG修复**: 不再手动操作DOM，而是通过刷新背包来更新UI
            // 检查待定队列中的数量，以防止用户超额使用
            const originalQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            const pendingUses = this.pendingActions
              .filter(action => action.action === 'use' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);

            if (originalQuantity - pendingUses <= 0) {
              this.showTemporaryMessage(`${itemName} đã dùng hết hoặc đã có trong hàng đợi lệnh.`);
              return;
            }

            // 更新指令队列
            const existingAction = this.pendingActions.find(
              action => action.action === 'use' && action.itemName === itemName,
            );

            if (existingAction) {
              existingAction.quantity++;
            } else {
              this.pendingActions.push({
                action: 'use',
                itemName: itemName,
                quantity: 1,
              });
            }

            this.showTemporaryMessage(`Đã thêm [Dùng ${itemName}] vào hàng đợi lệnh`);
            this.savePendingActions();

            // 通过重新渲染整个背包来保证UI一致性
            this.showInventory();
          },

          discardItem(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('Thông tin vật phẩm bị lỗi, không thể vứt.');
              return;
            }

            const hasQuantity = item.hasOwnProperty('quantity');
            
            if (hasQuantity && (category === 'Đan Dược' || category === 'Tạp Vật')) {
              // 有数量的物品，需要输入丢弃数量
              this.promptDiscardQuantity(item, category, itemElement);
            } else {
              // 装备类物品，直接确认丢弃
              this.confirmDiscardItem(item, category, itemElement, 1);
            }
          },

          async promptDiscardQuantity(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            
            // 计算可丢弃的数量（减去待处理队列中的使用和丢弃数量）
            const pendingUses = this.pendingActions
              .filter(action => action.action === 'use' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);
            const pendingDiscards = this.pendingActions
              .filter(action => action.action === 'discard' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);
            const availableQuantity = currentQuantity - pendingUses - pendingDiscards;

            if (availableQuantity <= 0) {
              this.showTemporaryMessage(`${itemName} không có số lượng để vứt.`);
              return;
            }

            return new Promise((resolve) => {
              // 创建数量输入模态框
              const modal = document.createElement('div');
              modal.className = 'modal-overlay';
              modal.style.display = 'flex';
              modal.style.zIndex = '2000';
              modal.innerHTML = `
                <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                  <div class="modal-header">
                    <h2 class="modal-title">Vứt vật phẩm</h2>
                  </div>
                  <div class="modal-body" style="padding: 20px;">
                    <p style="margin-bottom: 15px; color: #c9aa71;">Vui lòng nhập số lượng <strong>${itemName}</strong> muốn vứt:</p>
                    <p style="font-size: 12px; color: #8b7355; margin-bottom: 10px;">Số lượng có thể vứt hiện tại: ${availableQuantity}</p>
                    <input type="number" id="discard-quantity-input" min="1" max="${availableQuantity}" value="1"
                           style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                  color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                      <button id="discard-quantity-cancel" class="interaction-btn">Hủy</button>
                      <button id="discard-quantity-confirm" class="interaction-btn" style="background: #8b0000; border-color: #ff6b6b;">Xác nhận vứt</button>
                    </div>
                  </div>
                </div>
              `;

              const container = document.querySelector('.guixu-root-container');
              container.appendChild(modal);

              const input = modal.querySelector('#discard-quantity-input');
              const confirmBtn = modal.querySelector('#discard-quantity-confirm');
              const cancelBtn = modal.querySelector('#discard-quantity-cancel');

              confirmBtn.addEventListener('click', () => {
                const quantity = parseInt(input.value, 10);
                if (isNaN(quantity) || quantity <= 0 || quantity > availableQuantity) {
                  this.showTemporaryMessage('Vui lòng nhập số lượng vứt hợp lệ');
                  return;
                }
                modal.remove();
                this.confirmDiscardItem(item, category, itemElement, quantity);
                resolve();
              });

              cancelBtn.addEventListener('click', () => {
                modal.remove();
                resolve();
              });

              // 自动聚焦
              setTimeout(() => input.focus(), 100);
            });
          },

          confirmDiscardItem(item, category, itemElement, quantity = 1) {
            const itemName = this.SafeGetValue(item, 'name');
            const hasQuantity = item.hasOwnProperty('quantity');
            
            let confirmMessage;
            if (hasQuantity) {
              confirmMessage = `Chắc chắn muốn vứt ${quantity} cái ${itemName} không? Thao tác này không thể hoàn tác.`;
            } else {
              confirmMessage = `Chắc chắn muốn vứt ${itemName} không? Thao tác này không thể hoàn tác.`;
            }

            this.showCustomConfirm(confirmMessage, () => {
              // 添加到指令队列
              this.pendingActions.push({
                action: 'discard',
                itemName: itemName,
                category: category,
                quantity: quantity
              });

              this.savePendingActions();
              
              // 前端乐观显示：刷新背包以反映变化
              this.showInventory();
              
              if (hasQuantity) {
                this.showTemporaryMessage(`Đã thêm [Vứt ${quantity} cái ${itemName}] vào hàng đợi lệnh`);
              } else {
                this.showTemporaryMessage(`Đã thêm [Vứt ${itemName}] vào hàng đợi lệnh`);
              }
            });
          },

          showExtractedContent() {
            this.openModal('extracted-content-modal');
            const journeyEl = document.getElementById('extracted-journey');
            const pastLivesEl = document.getElementById('extracted-past-lives');
            const variablesEl = document.getElementById('extracted-variable-changes');
            const sentPromptEl = document.getElementById('sent-prompt-display');

            if (sentPromptEl) {
              sentPromptEl.textContent = this.lastSentPrompt || 'Chưa gửi nội dung nào';
            }
            if (journeyEl) {
              journeyEl.textContent = this.lastExtractedJourney || 'Không trích xuất được nội dung';
            }
            if (pastLivesEl) {
              pastLivesEl.textContent = this.lastExtractedPastLives || 'Không trích xuất được nội dung';
            }
            if (variablesEl) {
              variablesEl.textContent = this.lastExtractedVariables || 'Lần này không có thay đổi biến';
            }
            const novelModeEl = document.getElementById('extracted-novel-mode');
            const novelModeBtn = document.getElementById('btn-write-novel-mode');
            if (novelModeEl && novelModeBtn) {
              // 新逻辑：始终显示提取到的内容。按钮可用性仅取决于内容是否存在。
              novelModeEl.textContent = this.lastExtractedNovelText || 'Không trích xuất được nội dung chính trong phản hồi AI hiện tại.';
              novelModeBtn.disabled = !this.lastExtractedNovelText;

              // 更新标签文本以提供关于自动写入状态的即时反馈
              const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
              if (label) {
                const statusText = this.isNovelModeEnabled ? 'Bật' : 'Tắt';
                label.title = `Nhấn để chuyển đổi trạng thái tự động ghi, hiện tại là: ${statusText}`;
              }
            }

            // 新增：处理提取的角色卡
            const characterCardEl = document.getElementById('extracted-character-card');
            const characterCardBtn = document.getElementById('btn-write-character-card');
            if (characterCardEl && characterCardBtn) {
              characterCardEl.textContent = this.lastExtractedCharacterCard || 'Không trích xuất được nội dung thẻ nhân vật.';
              characterCardBtn.disabled = !this.lastExtractedCharacterCard;
            }
          },

          async showJourney() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // 确保输入框显示正确的序号
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'Hành Trình Kiếp Này';

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang đọc lại cuộn giấy vận mệnh...</p>';
            try {
              const bookName = '1归墟';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `Hành Trình Kiếp Này(${index})` : 'Hành Trình Kiếp Này';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

              if (!journeyEntry) {
                console.warn(`Không tìm thấy mục có tiêu đề "${journeyKey}" trong Lorebook "${bookName}".`);
              }
              body.innerHTML = this.renderJourneyFromContent(journeyEntry);
              // Bind click event listeners
              this.bindJourneyListeners();
            } catch (error) {
              console.error('Lỗi khi đọc “Hành Trình Kiếp Này”:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi đọc lại ký ức: ${error.message}</p>`;
            }
          },

          async showPastLives() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // 确保输入框显示正确的序号
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'Sóng Nước Kiếp Xưa';

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang ngược dòng thời gian...</p>';
            try {
              const bookName = 'Quy Khư 2.5-UI';
              const index = this.unifiedIndex;
              const pastLivesKey = index > 1 ? `Sóng Nước Kiếp Xưa(${index})` : 'Sóng Nước Kiếp Xưa';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);

              if (!pastLivesEntry) {
                console.warn(`Không tìm thấy mục có tiêu đề "${pastLivesKey}" trong Lorebook "${bookName}".`);
              }

              body.innerHTML = this.renderPastLives(pastLivesEntry);
            } catch (error) {
              console.error('Lỗi khi đọc “Sóng Nước Kiếp Xưa”:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi ngược dòng thời gian: ${error.message}</p>`;
            }
          },

          // --- Rendering Logic for Dynamic Content (Lorebooks) ---
          parseJourneyEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return [];
            try {
              const events = [];
              const eventBlocks = contentString
                .trim()
                .split(/Số thứ tự\|/g)
                .slice(1);

              eventBlocks.forEach(block => {
                const fullBlock = `Số thứ tự|${block}`.trim();
                const event = {};
                
                // 定义字段顺序，用于正确解析多行内容
                const fieldOrder = ['Số thứ tự', 'Ngày tháng', 'Tiêu đề', 'Địa điểm', 'Nhân vật', 'Mô tả', 'Quan hệ nhân vật', 'Thẻ', 'Thông tin quan trọng', 'Nội tuyến và Phục bút', 'Hệ thống tự động hóa'];
                
                let currentFieldIndex = 0;
                let currentKey = '';
                let currentValue = '';
                
                const lines = fullBlock.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  let foundField = false;
                  
                  // 检查是否是新字段的开始
                  for (let j = currentFieldIndex; j < fieldOrder.length; j++) {
                    const field = fieldOrder[j];
                    if (line.startsWith(field + '|')) {
                      // 保存前一个字段的值
                      if (currentKey && currentValue.trim()) {
                        event[currentKey] = currentValue.trim();
                      }
                      
                      // 开始新字段
                      currentKey = field;
                      currentValue = line.substring(field.length + 1);
                      currentFieldIndex = j;
                      foundField = true;
                      break;
                    }
                  }
                  
                  // 如果不是新字段，则追加到当前字段值
                  if (!foundField && currentKey) {
                    currentValue += '\n' + line;
                  }
                }
                
                // 保存最后一个字段
                if (currentKey && currentValue.trim()) {
                  event[currentKey] = currentValue.trim();
                }
                
                if (event['Số thứ tự']) {
                  events.push(event);
                }
              });
              return events;
            } catch (e) {
              console.error('Phân tích mục Hành Trình Kiếp Này thất bại:', e);
              return [];
            }
          },

          parsePastLifeEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return {};
            try {
              const data = {};
              const lines = contentString.trim().split('\n');
              lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 2) {
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('|').trim();
                  data[key] = value;
                }
              });
              return data;
            } catch (e) {
              console.error('Phân tích mục Sóng Nước Kiếp Xưa thất bại:', e);
              return {};
            }
          },

          renderJourneyFromContent(entry) {
            if (!entry || !entry.content)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">Kiếp này chưa lưu lại dấu vết nào.</p>';

            const events = this.parseJourneyEntry(entry.content);
            if (events.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">Định dạng nội dung bị lỗi, không thể phân tích sự kiện.</p>';

            events.sort((a, b) => (parseInt(a['Số thứ tự'], 10) || 0) - (parseInt(b['Số thứ tự'], 10) || 0));

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            events.forEach((eventData, index) => {
              const eventId = `event-${entry.uid}-${index}`;
              const date = eventData['Ngày tháng'] || 'Thời gian không rõ';
              const title = eventData['Tiêu đề'] || 'Không có tiêu đề';
              const location = eventData['Địa điểm'] || 'Địa điểm không rõ';
              const description = eventData['Mô tả'] || 'Không có mô tả chi tiết.';
              const characters = eventData['Nhân vật'] || '';
              const relationships = eventData['Quan hệ nhân vật'] || '';
              const importantInfo = eventData['Thông tin quan trọng'] || '';
              const hiddenPlot = eventData['Nội tuyến và Phục bút'] || '';
              const autoSystem = eventData['Hệ thống tự động hóa'] || '';

              const tagsHtml = (eventData['Thẻ'] || '')
                .split('|')
                .map(tag => tag.trim())
                .filter(tag => tag)
                .map(tag => `<span class="tag-item">${tag}</span>`)
                .join('');

              // 基本信息（默认显示）
              const basicInfo = `
                <div class="timeline-header">
                  <div class="timeline-date">${date}</div>
                  <div class="timeline-tags">${tagsHtml}</div>
                </div>
                <div class="timeline-title">${title}</div>
                <div class="timeline-location" style="font-size: 12px; color: #8b7355; margin: 5px 0;">Địa điểm：${location}</div>
                <div class="timeline-description">${description}</div>
              `;

              // 详细信息（需要点击3次才显示）
              const detailedInfo = `
                <div class="timeline-detailed-info" id="detailed-${eventId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.3);">
                  ${characters ? `<div class="detail-section"><strong>Nhân vật：</strong>${characters}</div>` : ''}
                  ${relationships ? `<div class="detail-section"><strong>Quan hệ nhân vật：</strong>${relationships}</div>` : ''}
                  ${importantInfo ? `<div class="detail-section"><strong>Thông tin quan trọng：</strong>${importantInfo}</div>` : ''}
                  ${hiddenPlot ? `<div class="detail-section"><strong>Nội tuyến và Phục bút：</strong>${hiddenPlot}</div>` : ''}
                  ${autoSystem ? `<div class="detail-section"><strong>Hệ thống tự động hóa：</strong><pre style="white-space: pre-wrap; font-size: 11px; color: #a09c91;">${autoSystem}</pre></div>` : ''}
                </div>
              `;

              html += `
                <div class="timeline-event" data-event-id="${eventId}" data-click-count="0" style="cursor: pointer;">
                  <div class="timeline-content">
                    ${basicInfo}
                    ${detailedInfo}
                  </div>
                </div>`;
            });
            html += '</div>';
            return html;
          },

          renderPastLives(entry) {
            if (!entry || !entry.content)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">Không tìm thấy dấu vết của tiền kiếp.</p>';

            const pastLifeBlocks = entry.content
              .trim()
              .split(/Kiếp thứ x\|/g)
              .slice(1);
            if (pastLifeBlocks.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">Định dạng nội dung bị lỗi, không thể phân tích ghi chép tiền kiếp.</p>';

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            pastLifeBlocks.forEach(block => {
              const fullContent = `Kiếp thứ x|${block}`;
              const data = this.parsePastLifeEntry(fullContent);
              const title = `Kiếp thứ ${data['Kiếp thứ x'] || '?'}`;

              html += `
                        <div class="timeline-event">
                            <div class="timeline-content">
                                <div class="timeline-title">${title}</div>
                                <div class="past-life-details">
                                    <div class="detail-item"><strong>Mạch sự kiện:</strong> ${
                                      data['Mạch sự kiện'] || 'Không rõ'
                                    }</div>
                                    <div class="detail-item"><strong>Tổng quan kiếp này:</strong> ${
                                      data['Tổng quan kiếp này'] || 'Không rõ'
                                    }</div>
                                    <div class="detail-item"><strong>Thành tựu kiếp này:</strong> ${
                                      data['Thành tựu kiếp này'] || 'Không'
                                    }</div>
                                    <div class="detail-item"><strong>Vật phẩm đạt được:</strong> ${
                                      data['Vật phẩm đạt được kiếp này'] || 'Không'
                                    }</div>
                                    <div class="detail-item"><strong>Quan hệ nhân vật:</strong> ${
                                      data['Mạng lưới quan hệ nhân vật kiếp này'] || 'Không'
                                    }</div>
                                    <div class="detail-item"><strong>Nguyên nhân tử vong:</strong> ${
                                      data['Nguyên nhân tử vong'] || 'Không rõ'
                                    }</div>
                                    <div class="detail-item"><strong>Tổng kết kiếp này:</strong> ${
                                      data['Tổng kết kiếp này'] || 'Không'
                                    }</div>
                                    <div class="detail-item"><strong>Đánh giá kiếp này:</strong> ${
                                      data['Đánh giá kiếp này'] || 'Không'
                                    }</div>
                                </div>
                            </div>
                        </div>`;
            });
            html += '</div>';
            return html;
          },

          async renderPastLifeDetails(bookName) {
            const detailsContainer = document.getElementById('past-life-details');
            if (!detailsContainer) return;
            detailsContainer.style.display = 'block';
            detailsContainer.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Đang đọc ký ức của kiếp này...</p>';
            try {
              const entries = await TavernHelper.getLorebookEntries(bookName, 'summary');
              if (entries && entries.length > 0) {
                const summaryData = JSON.parse(entries[0].content);
                detailsContainer.innerHTML = `
                            <h4>${bookName} - Tổng quan kết cục</h4>
                            <p><strong>Cảnh giới cuối cùng:</strong> ${summaryData.finalStats.境界}</p>
                            <p><strong>Thời gian sống sót:</strong> ${summaryData.finalStats.存活时间}</p>
                            <p><strong>Thành tựu chính:</strong> ${summaryData.achievements.join('、 ')}</p>
                            <p><strong>Hối tiếc cuối cùng:</strong> ${summaryData.regrets}</p>
                            <p><strong>Sự kiện quan trọng:</strong></p>
                            <ul style="padding-left: 20px;">${summaryData.keyEvents
                              .map(e => `<li>${e}</li>`)
                              .join('')}</ul>`;
              } else {
                detailsContainer.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Không tìm thấy tổng quan kết cục của kiếp này.</p>';
              }
            } catch (error) {
              console.error(`Error fetching details for ${bookName}:`, error);
              detailsContainer.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">Lỗi khi đọc ký ức kiếp này: ${error.message}</p>`;
            }
          },

          // --- Dynamic Event Listeners for Lorebook content ---
          bindJourneyListeners() {
            // Bind click listeners for Hành Trình Kiếp Này events
            const timelineContainer = document.querySelector('.timeline-container');
            if (timelineContainer) {
              timelineContainer.addEventListener('click', (e) => {
                const timelineEvent = e.target.closest('.timeline-event');
                if (timelineEvent) {
                  this.handleJourneyEventClick(timelineEvent);
                }
              });
            }
          },

          handleJourneyEventClick(eventElement) {
            const detailedInfo = eventElement.querySelector('.timeline-detailed-info');
            
            // 检查详细信息是否已经显示
            if (detailedInfo && detailedInfo.style.display === 'block') {
              // 如果已显示，则隐藏
              detailedInfo.style.display = 'none';
              eventElement.style.cursor = 'pointer';
              // 重置点击计数，允许重新开始3次点击
              eventElement.dataset.clickCount = '0';
            } else {
              // 如果未显示，继续原有的3次点击逻辑
              const currentCount = parseInt(eventElement.dataset.clickCount || '0', 10);
              const newCount = currentCount + 1;
              eventElement.dataset.clickCount = newCount;

              // 当点击3次时显示详细信息
              if (newCount >= 3) {
                if (detailedInfo) {
                  detailedInfo.style.display = 'block';
                }
                
                // 保持点击样式，允许再次点击隐藏
                eventElement.style.cursor = 'pointer';
              }
            }
          },

          async handleRewind(eventId, eventTitle) {
            // “回溯”按钮相关逻辑已移除
          },

          // 此函数不再需要，提取逻辑已合并到 loadAndDisplayCurrentScene
          processAIResponse() {
            // 空函数或可直接删除
          },

          // --- 新增：写入世界书的核心逻辑 ---
          // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
          async writeJourneyToLorebook(silent = false) {
            const content = this.lastExtractedJourney;
            await this.writeToLorebook('Hành Trình Kiếp Này', content, silent);
          },

          async writePastLivesToLorebook(silent = false) {
            const content = this.lastExtractedPastLives;
            await this.writeToLorebook('Sóng Nước Kiếp Xưa', content, silent);
          },

          async writeNovelModeToLorebook(silent = false) {
            const content = this.lastExtractedNovelText;
            await this.writeToLorebook('Chế độ tiểu thuyết', content, silent);
          },

          // 最终版：重构写入逻辑，支持动态索引和条目创建
          async writeToLorebook(baseEntryKey, contentToWrite, silent = false) {
            if (!contentToWrite || contentToWrite.trim() === '') {
              if (!silent) this.showTemporaryMessage('Không có nội dung để ghi.');
              return;
            }

            // 1. 根据序号生成最终的条目名称
            const index = this.unifiedIndex;
            const finalEntryKey = index > 1 ? `${baseEntryKey}(${index})` : baseEntryKey;
            const bookName = 'Quy Khư 2.5-UI';

            let reformattedContent = contentToWrite.trim();
            let buttonId;

            // 2. 内容格式化 (逻辑保持不变)
            if (baseEntryKey === 'Hành Trình Kiếp Này' || baseEntryKey === 'Sóng Nước Kiếp Xưa') {
              const journeyFields = ['Số thứ tự', 'Ngày tháng', 'Tiêu đề', 'Mô tả', 'Thẻ'];
              const pastLivesFields = [
                'Kiếp thứ x', 'Mạch sự kiện', 'Tổng quan kiếp này', 'Thành tựu kiếp này', 'Vật phẩm đạt được kiếp này',
                'Mạng lưới quan hệ nhân vật kiếp này', 'Nguyên nhân tử vong', 'Tổng kết kiếp này', 'Đánh giá kiếp này',
              ];
              const fields = baseEntryKey === 'Hành Trình Kiếp Này' ? journeyFields : pastLivesFields;

              const parseContent = (text, fieldList) => {
                const data = {};
                let tempText = text.replace(/\r\n/g, '\n');
                fieldList.forEach((field, fIndex) => {
                  const nextField = fieldList[fIndex + 1];
                  const startMarker = `${field}|`;
                  const startIndex = tempText.indexOf(startMarker);
                  if (startIndex !== -1) {
                    let endIndex;
                    if (nextField) {
                      const nextMarkerIndex = tempText.indexOf(`${nextField}|`, startIndex);
                      endIndex = nextMarkerIndex !== -1 ? nextMarkerIndex : undefined;
                    }
                    let value = tempText.substring(startIndex + startMarker.length, endIndex);
                    data[field] = value.trim();
                  }
                });
                return data;
              };

              const parsedData = parseContent(contentToWrite, fields);
              if (Object.keys(parsedData).length === 0) {
                if (!silent) this.showTemporaryMessage(`Không thể phân tích nội dung của “${baseEntryKey}”, thao tác ghi đã bị hủy.`);
                return;
              }
              reformattedContent = fields
                .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                .filter(Boolean)
                .join('\n');
              
              buttonId = baseEntryKey === 'Hành Trình Kiếp Này' ? 'btn-write-journey' : 'btn-write-past-lives';
            } else if (baseEntryKey === 'Chế độ tiểu thuyết') {
              buttonId = 'btn-write-novel-mode';
            }

            const button = document.getElementById(buttonId);
            if (button && !silent) button.textContent = 'Đang ghi...';

            try {
              // 3. 检查条目是否存在，如果不存在则创建
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              let targetEntry = allEntries.find(entry => entry.comment === finalEntryKey);

              if (!targetEntry) {
                if (!silent) this.showTemporaryMessage(`Mục "${finalEntryKey}" không tồn tại, đang tạo...`);
                
                // 从基础条目（如“Hành Trình Kiếp Này”）复制属性来创建新条目
                const baseEntryTemplate = allEntries.find(entry => entry.comment === baseEntryKey);
                const newEntryData = {
                  comment: finalEntryKey,
                  content: reformattedContent,
                  keys: baseEntryTemplate ? [...baseEntryTemplate.keys, finalEntryKey] : [finalEntryKey],
                  enabled: false,
                  // 复制其他可能存在的元数据
                  selective: baseEntryTemplate?.selective,
                  constant: baseEntryTemplate?.constant,
                  position: baseEntryTemplate?.position,
                  case_sensitive: baseEntryTemplate?.case_sensitive,
                };

                await TavernHelper.createLorebookEntries(bookName, [newEntryData]);
                if (!silent) this.showTemporaryMessage(`Đã tạo và ghi thành công vào “${finalEntryKey}”.`);
                
                // 创建后，如果自动开关是开启的，立即触发一次更新以确保新条目被正确启用
                if (this.isAutoToggleLorebookEnabled) {
                    this.updateAutoToggledEntries();
                }

              } else {
                // 4. 如果条目存在，则追加内容
                const existingContent = targetEntry.content || '';
                if (existingContent.includes(reformattedContent)) {
                  if (!silent) this.showTemporaryMessage('Nội dung đã tồn tại, không cần ghi lại.');
                  return;
                }

                const updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: updatedContent }]);
                if (!silent) this.showTemporaryMessage(`Đã thêm nội dung thành công vào “${finalEntryKey}”.`);
              }

              if (button && !silent) {
                button.textContent = 'Ghi thành công';
                setTimeout(() => { button.textContent = 'Ghi vào Lorebook'; }, 2000);
              }

            } catch (error) {
              console.error(`Lỗi khi ghi vào Lorebook "${finalEntryKey}":`, error);
              if (!silent) {
                this.showTemporaryMessage(`Ghi thất bại: ${error.message}`);
                if (button) button.textContent = 'Ghi thất bại';
              }
            } finally {
                if (button && !silent && button.textContent === 'Đang ghi...') {
                    button.textContent = 'Ghi vào Lorebook';
                }
            }
          },

          async writeCharacterCardToLorebook() {
            const content = this.lastExtractedCharacterCard;
            if (!content) {
              this.showTemporaryMessage('Không có nội dung nhân vật để ghi.');
              return;
            }

            const button = document.getElementById('btn-write-character-card');
            if (button) button.textContent = 'Đang ghi...';

            try {
              const lines = content.trim().split('\n');
              const characterData = {};
              lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 2) {
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('|').trim();
                  characterData[key] = value;
                }
              });

              const characterName = characterData['Tên'];
              if (!characterName) {
                throw new Error('Không thể tìm thấy “Tên” của nhân vật từ nội dung được trích xuất.');
              }

              const bookName = 'Quy Khư 2.5-UI';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const existingEntry = allEntries.find(entry => entry.comment === characterName);

              if (existingEntry) {
                this.showTemporaryMessage(`Nhân vật “${characterName}” đã tồn tại, vui lòng sửa thủ công.`);
                if (button) button.textContent = 'Ghi vào Lorebook';
                return;
              }

              await TavernHelper.createLorebookEntries(bookName, [
                {
                  comment: characterName,
                  keys: [characterName],
                  content: content.trim(),
                  enabled: true,
                },
              ]);

              this.showTemporaryMessage(`Đã tạo thành công nhân vật “${characterName}”.`);
              if (button) button.textContent = 'Ghi thành công';
              setTimeout(() => {
                if (button) button.textContent = 'Ghi vào Lorebook';
              }, 2000);
            } catch (error) {
              console.error('Lỗi khi ghi thẻ nhân vật vào Lorebook:', error);
              this.showTemporaryMessage(`Ghi thất bại: ${error.message}`);
              if (button) button.textContent = 'Ghi thất bại';
            }
          },

          async updateCurrentSceneLorebook(sceneContent) {
            // 增加健壮性检查，防止写入空内容
            if (!sceneContent || sceneContent.trim() === '') {
              console.warn('[Quy Khư] Đang cố ghi nội dung trống vào “Cảnh Hiện Tại”, thao tác đã bị hủy.');
              return;
            }
            const bookName = 'Quy Khư 2.5-UI';
            const sceneKey = 'Cảnh hiện tại';
            try {
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const sceneEntry = allEntries.find(entry => entry.comment === sceneKey);

              if (!sceneEntry) {
                console.warn(
                  `[Quy Khư] Không tìm thấy mục Lorebook "${sceneKey}", không thể cập nhật nội dung cảnh. Vui lòng tạo nó trong Lorebook '${bookName}'.`,
                );
                // 如果条目不存在，我们可以选择创建一个
                await TavernHelper.createLorebookEntries(bookName, [
                  {
                    comment: sceneKey,
                    content: sceneContent,
                    keys: [],
                  },
                ]);
                console.log(`[Quy Khư] Đã tạo và cập nhật nội dung "${sceneKey}".`);
                return;
              }

              // Use overwrite update
              await TavernHelper.setLorebookEntries(bookName, [{ uid: sceneEntry.uid, content: sceneContent }]);
              console.log(`[Quy Khư] Cập nhật thành công nội dung "${sceneKey}".`);
            } catch (error) {
              console.error(`[Quy Khư] Lỗi khi cập nhật "${sceneKey}":`, error);
            }
          },

          async loadAndDisplayCurrentScene(messageContent = null) {
            const gameTextDisplay = document.getElementById('game-text-display');
            if (!gameTextDisplay) return;

            try {
              let contentToParse = messageContent;

              // 如果没有直接提供内容，则从聊天记录中获取
              if (contentToParse === null) {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) return;
                const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant');
                if (lastAiMessage) {
                  contentToParse = lastAiMessage.message;
                }
              }

              if (contentToParse) {
                // 1. 更新主界面正文 (使用新的健壮的提取函数)
                const displayText = this._getDisplayText(contentToParse);
                gameTextDisplay.innerHTML = this.formatMessageContent(displayText);

                // 2. 同步提取所有标签内容到变量，用于“查看提取内容”模态框
                this.lastExtractedNovelText = this._extractLastTagContent('gametxt', contentToParse);
                this.lastExtractedJourney = this._extractLastTagContent('本世历程', contentToParse);
                this.lastExtractedPastLives = this._extractLastTagContent('往世涟漪', contentToParse);
                this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', contentToParse, true); // ignore case
                this.lastExtractedCharacterCard = this._extractLastTagContent('角色提取', contentToParse);
              }
            } catch (error) {
              console.error(`[Quy Khư] Lỗi khi tải và hiển thị cảnh hiện tại:`, error);
              gameTextDisplay.innerHTML = `<gametxt>Lỗi khi tải cảnh.</gametxt>`;
            }
          },

          // --- 新增：状态保存与自动写入逻辑 ---
          saveAutoWriteState(state) {
            try {
              localStorage.setItem('guixu_auto_write_enabled', state);
            } catch (e) {
              console.error('Lưu trạng thái tự động ghi thất bại:', e);
            }
          },

          loadAutoWriteState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_write_enabled');
              // 如果localStorage中没有保存过状态，则默认为true (开启)
              this.isAutoWriteEnabled = savedState === null ? true : savedState === 'true';
              const checkbox = document.getElementById('auto-write-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoWriteEnabled;
              }
              // 根据加载的状态决定是否启动轮询
              if (this.isAutoWriteEnabled) {
                this.startAutoWritePolling();
              }
            } catch (e) {
              console.error('Tải trạng thái tự động ghi thất bại:', e);
              this.isAutoWriteEnabled = false;
            }
          },

          saveNovelModeState(state) {
            try {
              localStorage.setItem('guixu_novel_mode_enabled', state);
            } catch (e) {
              console.error('Lưu trạng thái chế độ tiểu thuyết thất bại:', e);
            }
          },

          loadNovelModeState() {
            try {
              const savedState = localStorage.getItem('guixu_novel_mode_enabled');
              // 小说模式默认为 false (关闭)
              this.isNovelModeEnabled = savedState === 'true';
              const checkbox = document.getElementById('novel-mode-enabled-checkbox');
              if (checkbox) {
                checkbox.checked = this.isNovelModeEnabled;
              }
              // 根据加载的状态决定是否启动小说模式的轮询
              if (this.isNovelModeEnabled) {
                this.startNovelModeAutoWritePolling();
              }
            } catch (e) {
              console.error('Tải trạng thái chế độ tiểu thuyết thất bại:', e);
              this.isNovelModeEnabled = false;
            }
          },

          startAutoWritePolling() {
            this.stopAutoWritePolling(); // 先停止任何可能存在的旧轮询
            console.log('[Quy Khư] Bắt đầu thăm dò tự động ghi...');
            this.autoWriteIntervalId = setInterval(() => {
              // 直接调用按钮的逻辑，并传入 silent=true
              if (this.lastExtractedJourney) {
                this.writeJourneyToLorebook(true);
              }
              if (this.lastExtractedPastLives) {
                this.writePastLivesToLorebook(true);
              }
            }, 2000); // 每2秒检查一次
          },

          stopAutoWritePolling() {
            if (this.autoWriteIntervalId) {
              console.log('[Quy Khư] Dừng thăm dò tự động ghi.');
              clearInterval(this.autoWriteIntervalId);
              this.autoWriteIntervalId = null;
            }
          },

          // --- 新增：小说模式自动写入轮询 ---
          startNovelModeAutoWritePolling() {
            this.stopNovelModeAutoWritePolling(); // 先停止任何可能存在的旧轮询
            console.log('[Quy Khư] Bắt đầu thăm dò tự động ghi chế độ tiểu thuyết...');
            this.novelModeAutoWriteIntervalId = setInterval(() => {
              if (this.lastExtractedNovelText) {
                this.writeNovelModeToLorebook(true);
              }
            }, 2000); // 每2秒检查一次
          },

          stopNovelModeAutoWritePolling() {
            if (this.novelModeAutoWriteIntervalId) {
              console.log('[Quy Khư] Dừng thăm dò tự động ghi chế độ tiểu thuyết.');
              clearInterval(this.novelModeAutoWriteIntervalId);
              this.novelModeAutoWriteIntervalId = null;
            }
          },

          // --- 新增：装备状态保存与加载 ---
          saveEquipmentState() {
            try {
              localStorage.setItem('guixu_equipped_items', JSON.stringify(this.equippedItems));
            } catch (e) {
              console.error('Lưu trạng thái trang bị thất bại:', e);
            }
          },

          // **逻辑重构**: 彻底简化的加载函数
          loadEquipmentState() {
            try {
              const savedState = localStorage.getItem('guixu_equipped_items');
              if (savedState) {
                const loadedItems = JSON.parse(savedState);
                if (!loadedItems) return;

                this.equippedItems = loadedItems;

                const defaultTextMap = {
                  wuqi: 'Vũ Khí',
                  fangju: 'Phòng Cụ',
                  shipin: 'Phụ Kiện',
                  fabao1: 'Pháp Bảo',
                  zhuxiuGongfa: 'Công Pháp Chủ Tu',
                  fuxiuXinfa: 'Tâm Pháp Phụ Tu',
                };

                // 直接用 localStorage 的数据渲染UI
                for (const slotKey in defaultTextMap) {
                  const slotElement = document.getElementById(`equip-${slotKey}`);
                  if (!slotElement) continue;

                  const itemData = this.equippedItems[slotKey];

                  if (itemData && typeof itemData === 'object') {
                    const tier = this.SafeGetValue(itemData, 'tier', 'Phàm Phẩm');
                    const tierStyle = this.getTierStyle(tier);
                    slotElement.textContent = this.SafeGetValue(itemData, 'name');
                    slotElement.setAttribute('style', tierStyle);
                    slotElement.classList.add('equipped');
                    slotElement.dataset.itemDetails = JSON.stringify(itemData).replace(/'/g, "'");
                  } else {
                    slotElement.textContent = defaultTextMap[slotKey];
                    slotElement.classList.remove('equipped');
                    slotElement.removeAttribute('style');
                    delete slotElement.dataset.itemDetails;
                  }
                }
                this.updateDisplayedAttributes();
              }
            } catch (e) {
              console.error('Tải trạng thái trang bị thất bại:', e);
              localStorage.removeItem('guixu_equipped_items');
            }
          },

          savePendingActions() {
            try {
              localStorage.setItem('guixu_pending_actions', JSON.stringify(this.pendingActions));
            } catch (e) {
              console.error('Lưu trạng thái hàng đợi lệnh thất bại:', e);
            }
          },

          loadPendingActions() {
            try {
              const savedActions = localStorage.getItem('guixu_pending_actions');
              if (savedActions) {
                this.pendingActions = JSON.parse(savedActions) || [];
              }
            } catch (e) {
              console.error('Tải trạng thái hàng đợi lệnh thất bại:', e);
              this.pendingActions = [];
              localStorage.removeItem('guixu_pending_actions');
            }
          },
 
          // --- 新增：统一读写序号存取 ---
          saveUnifiedIndex() {
            try {
              localStorage.setItem('guixu_unified_index', this.unifiedIndex);
            } catch (e) {
              console.error('Lưu số thứ tự đọc/ghi thống nhất thất bại:', e);
            }
          },
 
          loadUnifiedIndex() {
            try {
              const savedIndex = localStorage.getItem('guixu_unified_index');
              if (savedIndex) {
                this.unifiedIndex = parseInt(savedIndex, 10) || 1;
              }
              const input = document.getElementById('unified-index-input');
              if (input) {
                input.value = this.unifiedIndex;
              }
            } catch (e) {
              console.error('Tải số thứ tự đọc/ghi thống nhất thất bại:', e);
              this.unifiedIndex = 1; // 出错时重置为1
            }
          },
 
           // --- 新增：自动开关世界书状态存取 ---
           saveAutoToggleState() {
             try {
               localStorage.setItem('guixu_auto_toggle_enabled', this.isAutoToggleLorebookEnabled);
             } catch (e) {
               console.error('Lưu trạng thái tự động bật/tắt thất bại:', e);
             }
           },
 
           loadAutoToggleState() {
             try {
               const savedState = localStorage.getItem('guixu_auto_toggle_enabled');
               this.isAutoToggleLorebookEnabled = savedState === 'true';
               const checkbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isAutoToggleLorebookEnabled;
               }
               // 根据加载的状态决定是否启动轮询
                if (this.isAutoToggleLorebookEnabled) {
                    this.startAutoTogglePolling();
                }
             } catch (e) {
               console.error('Tải trạng thái tự động bật/tắt thất bại:', e);
               this.isAutoToggleLorebookEnabled = false;
             }
           },

          // --- 新增：自动开关世界书轮询逻辑 (V2: 增加条目自动创建) ---
          async updateAutoToggledEntries(andDisableAll = false) {
            const bookName = 'Quy Khư 2.5-UI';
            const index = this.unifiedIndex;
            const journeyKey = index > 1 ? `Hành Trình Kiếp Này(${index})` : 'Hành Trình Kiếp Này';
            const pastLivesKey = index > 1 ? `Sóng Nước Kiếp Xưa(${index})` : 'Sóng Nước Kiếp Xưa';

            try {
                let allEntries = await TavernHelper.getLorebookEntries(bookName);
                const entriesToCreate = [];

                // --- 核心修复：检查并创建缺失的条目 ---
                const targetJourneyEntry = allEntries.find(e => e.comment === journeyKey);
                if (!targetJourneyEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'Hành Trình Kiếp Này');
                    if (baseTemplate) {
                        // 最终修复V3：使用正确的属性并确保启用
                        const newJourneyEntry = { ...baseTemplate };
                        delete newJourneyEntry.uid;
                        newJourneyEntry.comment = journeyKey;
                        newJourneyEntry.content = '';
                        newJourneyEntry.keys = [...(baseTemplate.keys || []), journeyKey];
                        newJourneyEntry.enabled = true;
                        newJourneyEntry.position = 'before_character_definition';
                        newJourneyEntry.order = 20;
                        entriesToCreate.push(newJourneyEntry);
                    }
                }

                const targetPastLivesEntry = allEntries.find(e => e.comment === pastLivesKey);
                if (!targetPastLivesEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'Sóng Nước Kiếp Xưa');
                    if (baseTemplate) {
                        // 最终修复V3：使用正确的属性并确保启用
                        const newPastLivesEntry = { ...baseTemplate };
                        delete newPastLivesEntry.uid;
                        newPastLivesEntry.comment = pastLivesKey;
                        newPastLivesEntry.content = '';
                        newPastLivesEntry.keys = [...(baseTemplate.keys || []), pastLivesKey];
                        newPastLivesEntry.enabled = true;
                        newPastLivesEntry.position = 'before_character_definition';
                        newPastLivesEntry.order = 19;
                        entriesToCreate.push(newPastLivesEntry);
                    }
                }

                if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[Tự động bật/tắt Quy Khư] Đã tự động tạo ${entriesToCreate.length} mục Lorebook mới.`);
                    // 重新获取所有条目，以包含新创建的条目
                    allEntries = await TavernHelper.getLorebookEntries(bookName);
                }
                // --- 修复结束 ---

                const entriesToUpdate = [];
                for (const entry of allEntries) {
                    const isJourneyEntry = entry.comment.startsWith('Hành Trình Kiếp Này');
                    const isPastLivesEntry = entry.comment.startsWith('Sóng Nước Kiếp Xưa');

                    if (!isJourneyEntry && !isPastLivesEntry) {
                        continue;
                    }

                    const isTarget = entry.comment === journeyKey || entry.comment === pastLivesKey;
                    const shouldBeEnabled = isTarget && !andDisableAll;

                    if (entry.enabled !== shouldBeEnabled) {
                        entriesToUpdate.push({ uid: entry.uid, enabled: shouldBeEnabled });
                    }
                }

                if (entriesToUpdate.length > 0) {
                    await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    console.log(`[Tự động bật/tắt Quy Khư] Đã cập nhật trạng thái của ${entriesToUpdate.length} mục Lorebook.`);
                }
            } catch (error) {
                console.error('[Tự động bật/tắt Quy Khư] Lỗi khi cập nhật trạng thái mục Lorebook:', error);
            }
          },

          startAutoTogglePolling() {
              this.stopAutoTogglePolling(false); // 先停止任何可能存在的旧轮询, 但不禁用条目
              console.log('[Quy Khư] Bắt đầu thăm dò tự động bật/tắt Lorebook...');
              this.updateAutoToggledEntries(); // 立即执行一次
              this.autoToggleIntervalId = setInterval(() => this.updateAutoToggledEntries(), 5000); // 每5秒轮询一次
          },

          stopAutoTogglePolling(disableEntries = true) {
              if (this.autoToggleIntervalId) {
                  console.log('[Quy Khư] Dừng thăm dò tự động bật/tắt Lorebook.');
                  clearInterval(this.autoToggleIntervalId);
                  this.autoToggleIntervalId = null;
              }
              if (disableEntries) {
                  // 停止时，确保所有相关条目都被禁用
                  this.updateAutoToggledEntries(true);
              }
          },

           // --- Misc ---
           applyRandomBackground() {
            const backgrounds = [
              'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
              'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
            ];
            const bgUrl = backgrounds[Math.floor(Math.random() * backgrounds.length)];
            const container = document.querySelector('.guixu-root-container');
            if (container) container.style.backgroundImage = `url('${bgUrl}')`;
          },

          async executeQuickSend() {
            const input = document.getElementById('quick-send-input');
            if (!input) return;
            const userMessage = input.value.trim();
            await this.handleAction(userMessage);
          },

          // 新增：处理所有动作的核心函数

          async handleAction(userMessage = '') {
              // 1. 整合输入
              let commandText = '';
              if (this.pendingActions.length > 0) {
                  commandText += '[Mệnh lệnh hành động của lượt này]\n';
                  this.pendingActions.forEach(cmd => {
                      let actionText = '';
                      switch (cmd.action) {
                          case 'equip': actionText = `Trang bị [${cmd.itemName}] vào ô [${cmd.category}].`; break;
                          case 'unequip': actionText = `Tháo [${cmd.itemName}] từ ô [${cmd.category}].`; break;
                          case 'use': actionText = `Dùng ${cmd.quantity} cái [${cmd.itemName}].`; break;
                          case 'discard':
                            if (cmd.quantity && cmd.quantity > 1) {
                              actionText = `Vứt ${cmd.quantity} cái [${cmd.itemName}].`;
                            } else {
                              actionText = `Vứt [${cmd.itemName}].`;
                            }
                            break;
                      }
                      commandText += `- ${actionText}\n`;
                  });
              }

              if (!userMessage && !commandText) {
                  this.showTemporaryMessage('Vui lòng nhập phản hồi hoặc thêm mệnh lệnh rồi gửi.');
                  return;
              }

              // 2. 构建 GenerateConfig 对象
              const generateConfig = {
                  injects: [],
                  should_stream: false, // 我们一次性处理整个响应
              };

              // 将用户输入和指令合并为一个 user-role 注入
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n'; // 指令在前
              }
              if (userMessage) {
                  combinedContent += `<行动选择>\n${userMessage}\n</行动选择>`;
              }

              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat', // 插入到聊天记录中
                      depth: 0,
                      should_scan: true, // 允许扫描关键字
                  });
              }

              this.lastSentPrompt = combinedContent; // 更新调试信息
              this.showWaitingMessage();

              try {
                  // 3. 调用 generate，传入配置对象
                  let aiResponse;
                  try {
                      aiResponse = await TavernHelper.generate(generateConfig);
                  } catch (e) {
                      throw new Error(`Gọi TavernHelper.generate thất bại: ${e.message}`);
                  }

                  // 诊断步骤：检查我们是否收到了有效的回复
                  if (typeof aiResponse !== 'string') {
                      throw new Error('AI không trả về văn bản hợp lệ, có thể là sự cố kết nối API hoặc phản hồi trống.');
                  }
                  console.log('[Quy Khư] Phản hồi gốc của AI:', aiResponse);

                  // 3. 修正：直接使用AI的完整回复作为更新脚本
                  // 根据 function.ts 的源码，后端的 extractCommands 函数会自行扫描并解析完整字符串中的所有指令。
                  // 前端不需要，也不应该进行任何形式的提取或清理。
                  const updateScript = aiResponse;
                  
                  // 为了调试目的，我们仍然在“查看提取内容”模态框中显示完整的AI回复
                  this.lastExtractedVariables = aiResponse;
                  console.log('[Quy Khư] Đã gửi phản hồi đầy đủ của AI làm kịch bản cho MVU:', updateScript);

                  // 4. 调用 mag_invoke_mvu 处理变量更新
                  if (updateScript && this.currentMvuState) {
                      const inputData = { old_variables: this.currentMvuState };
                      let mvuSucceeded = false;
                      try {
                          // 增加超时机制，防止 eventEmit 卡死
                          const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData);
                          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000));
                          await Promise.race([mvuPromise, timeoutPromise]);

                          if (inputData.new_variables) {
                              console.log('[Quy Khư] Trạng thái mvu đã được cập nhật:', inputData.new_variables);
                              this.currentMvuState = inputData.new_variables; // Update cache
                              this.renderUI(this.currentMvuState.stat_data); // Re-render UI
                              mvuSucceeded = true;
                          } else {
                              console.log('[Quy Khư] mvu không trả về trạng thái mới, thử phương án dự phòng phía client.');
                          }
                      } catch (eventError) {
                          console.error('[Quy Khư] Lỗi hoặc hết thời gian chờ khi gọi sự kiện mag_invoke_mvu, thử phương án dự phòng phía client:', eventError);
                      }

                      if (!mvuSucceeded) {
                          const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState);
                          if (modifiedState) {
                              this.currentMvuState = modifiedState;
                              this.renderUI(this.currentMvuState.stat_data);
                              console.log('[Quy Khư-Dự phòng] Mô phỏng cập nhật phía client thành công.');
                          }
                      }
                  } else {
                      console.log('[Quy Khư] Không tìm thấy kịch bản cập nhật hoặc trạng thái mvu hiện tại trống, bỏ qua cập nhật mvu.');
                  }
                  
                  await this.loadAndDisplayCurrentScene(aiResponse);

                  // 5. 静默保存到第0层，实现同层游玩
                  let messages;
                  try {
                      messages = await getChatMessages('0');
                  } catch (e) {
                      throw new Error(`Gọi getChatMessages('0') thất bại: ${e.message}`);
                  }

                  if (messages && messages.length > 0) {
                      const messageZero = messages[0];
                      
                      // **关键修复**: 直接使用未经处理的原始AI响应，以支持同层游玩
                      messageZero.message = aiResponse;
                      messageZero.data = this.currentMvuState;
                      try {
                          await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
                      } catch (e) {
                          throw new Error(`Gọi setChatMessages thất bại: ${e.message}`);
                      }
                      console.log('[Quy Khư] Đã cập nhật âm thầm tầng 0.');
                  } else {
                      console.error('[Quy Khư] Không tìm thấy tin nhắn tầng 0, không thể cập nhật.');
                  }

                  // 6. 清理工作
                  const input = document.getElementById('quick-send-input');
                  if (input) input.value = '';
                  this.pendingActions = [];
                  this.savePendingActions();
                  this.closeAllModals();
                  this.showTemporaryMessage('Mộng Tinh vĩ đại đã hồi đáp.');

              } catch (error) {
                  console.error('Lỗi khi xử lý hành động:', error);
                  this.showTemporaryMessage(`Giao tiếp với Mộng Tinh vĩ đại thất bại: ${error.message}`);
              } finally {
                  this.hideWaitingMessage();
                  // 最终修复：在所有操作完成后，主动、可靠地刷新UI，避免任何事件冲突。
                  await this.updateDynamicData();
                  this.loadEquipmentState();
              }
          },

          // --- 新增：快速指令列表相关函数 ---
          toggleQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (!popup) return;

            if (popup.style.display === 'block') {
              this.hideQuickCommands();
            } else {
              this.showQuickCommands();
            }
          },

          showQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (!popup) return;

            if (this.pendingActions.length === 0) {
              popup.innerHTML = '<div class="quick-command-empty">Chưa có mệnh lệnh nào chờ chấp hành</div>';
            } else {
              let listHtml = '<ul class="quick-command-list">';
              this.pendingActions.forEach(cmd => {
                let actionText = '';
                switch (cmd.action) {
                  case 'equip':
                    actionText = `Trang bị [${cmd.itemName}] vào ô [${cmd.category}].`;
                    break;
                  case 'unequip':
                    actionText = `Tháo [${cmd.itemName}] từ ô [${cmd.category}].`;
                    break;
                  case 'use':
                    actionText = `Dùng ${cmd.quantity} cái [${cmd.itemName}].`;
                    break;
                  case 'discard':
                    if (cmd.quantity && cmd.quantity > 1) {
                      actionText = `Vứt ${cmd.quantity} cái [${cmd.itemName}].`;
                    } else {
                      actionText = `Vứt [${cmd.itemName}].`;
                    }
                    break;
                }
                // 列表项不再需要data-command属性
                listHtml += `<li class="quick-command-item">${actionText}</li>`;
              });
              listHtml += '</ul>';
              popup.innerHTML = listHtml;
            }
            popup.style.display = 'block';
          },

          hideQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (popup) {
              popup.style.display = 'none';
            }
          },

          // --- 核心重构：前端备用MVU处理器 ---
          // 类脑/旅程梦星作品，禁止二传，禁止商业化，均无偿免费开源分享
          _applyUpdateFallback(script, currentMvuState) {
              if (!script || !currentMvuState) return null;
              
              const newState = _.cloneDeep(currentMvuState);
              let modified = false;

              const commands = this._extractCommands(script);

              for (const command of commands) {
                  try {
                      const path = this._trimQuotes(command.args[0]);
                      
                      switch (command.command) {
                          case 'set': {
                              const newValueStr = command.args.length >= 2 ? command.args[1] : undefined;
                              if(newValueStr === undefined) continue;
                              let newValue = this._parseCommandValue(newValueStr);
                              
                              if (newValue instanceof Date) newValue = newValue.toISOString();

                              _.set(newState.stat_data, path, newValue);
                              modified = true;
                              break;
                          }
                          case 'add': {
                              const value = _.get(newState.stat_data, path);
                              const delta = this._parseCommandValue(command.args[1]);
                              if (typeof value === 'number' && typeof delta === 'number') {
                                  _.set(newState.stat_data, path, value + delta);
                                  modified = true;
                              }
                              break;
                          }
                          case 'remove': {
                              _.unset(newState.stat_data, path);
                              modified = true;
                              break;
                          }
                          case 'assign':
                          case 'insert': {
                              if (command.args.length === 2) {
                                  // Handles _.assign('path', value)
                                  const valueToAssign = this._parseCommandValue(command.args[1]);
                                  const parentCollection = _.get(newState.stat_data, path);

                                  // Special handling for our [data_array, "description"] structure
                                  if (Array.isArray(parentCollection) && parentCollection.length === 2 && Array.isArray(parentCollection[0]) && typeof parentCollection[1] === 'string') {
                                      const innerArray = parentCollection[0];
                                      const description = parentCollection[1];
                                      const newInnerArray = innerArray.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      const newParentArray = [newInnerArray, description];
                                      _.set(newState.stat_data, path, newParentArray);
                                      modified = true;
                                  } else if (Array.isArray(parentCollection)) {
                                      // Standard immutable update for regular arrays
                                      const newCollection = parentCollection.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  } else if (_.isObject(parentCollection)) {
                                      // Merge for objects
                                      _.merge(parentCollection, valueToAssign);
                                      modified = true;
                                  } else {
                                      // If path doesn't exist, just set it
                                      _.set(newState.stat_data, path, valueToAssign);
                                      modified = true;
                                  }
                              } else if (command.args.length >= 3) {
                                  // Handles _.assign('path', key, value)
                                  const keyOrIndex = this._parseCommandValue(command.args[1]);
                                  const valueToAssign = this._parseCommandValue(command.args[2]);
                                  let collection = _.get(newState.stat_data, path);

                                  if (Array.isArray(collection)) {
                                      if (typeof keyOrIndex === 'number') {
                                          const newCollection = [...collection]; // Create a shallow copy for immutability
                                          newCollection.splice(keyOrIndex, 0, valueToAssign);
                                          _.set(newState.stat_data, path, newCollection);
                                          modified = true;
                                      }
                                  } else if (_.isObject(collection)) {
                                      _.set(collection, String(keyOrIndex), valueToAssign);
                                      modified = true;
                                  } else {
                                      // If collection doesn't exist, create it
                                      const newCollection = {};
                                      _.set(newCollection, String(keyOrIndex), valueToAssign);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  }
                              }
                              break;
                          }
                      }
                  } catch (e) {
                      console.error(`[Quy Khư-Dự phòng] Xử lý mệnh lệnh thất bại:`, command, e);
                  }
              }

              return modified ? newState : null;
          },

          // --- 内部辅助函数，从 function.ts 移植 ---
          _trimQuotes(str) {
              if (typeof str !== 'string') return str;
              return str.replace(/^['"` ]*(.*?)['"` ]*$/, '$1');
          },
          
          _parseCommandValue(valStr) {
              if (typeof valStr !== 'string') return valStr;
              const trimmed = valStr.trim();
              if (trimmed === 'true') return true;
              if (trimmed === 'false') return false;
              if (trimmed === 'null') return null;
              if (trimmed === 'undefined') return undefined;
              try {
                  return JSON.parse(trimmed);
              } catch (e) {
                  if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                      try {
                          return new Function(`return ${trimmed};`)();
                      } catch (err) { /* continue */ }
                  }
              }
              return this._trimQuotes(valStr);
          },

          _extractCommands(inputText) {
              const results = [];
              let i = 0;
              while (i < inputText.length) {
                  const match = inputText.substring(i).match(/_\.(set|assign|remove|add|insert)\(/);
                  if (!match || match.index === undefined) break;
                  
                  const commandType = match[1];
                  const start = i + match.index;
                  const openParen = start + match[0].length;
                  const closeParen = this._findMatchingCloseParen(inputText, openParen);
                  
                  if (closeParen === -1) {
                      i = openParen;
                      continue;
                  }
                  
                  let endPos = closeParen + 1;
                  if (endPos >= inputText.length || inputText[endPos] !== ';') {
                      i = closeParen + 1;
                      continue;
                  }
                  endPos++;
                  
                  const paramsString = inputText.substring(openParen, closeParen);
                  const params = this._parseParameters(paramsString);
                  
                  results.push({ command: commandType, args: params });
                  i = endPos;
              }
              return results;
          },

          _findMatchingCloseParen(str, startPos) {
              let parenCount = 1;
              let inQuote = false;
              let quoteChar = '';
              for (let i = startPos; i < str.length; i++) {
                  const char = str[i];
                  if ((char === '"' || char === "'" || char === '`') && str[i - 1] !== '\\') {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      else if (char === ')') {
                          parenCount--;
                          if (parenCount === 0) return i;
                      }
                  }
              }
              return -1;
          },

          _parseParameters(paramsString) {
              const params = [];
              let currentParam = '';
              let inQuote = false;
              let quoteChar = '';
              let bracketCount = 0;
              let braceCount = 0;
              let parenCount = 0;
              for (let i = 0; i < paramsString.length; i++) {
                  const char = paramsString[i];
                  if ((char === '"' || char === "'" || char === '`') && (i === 0 || paramsString[i - 1] !== '\\')) {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      if (char === ')') parenCount--;
                      if (char === '[') bracketCount++;
                      if (char === ']') bracketCount--;
                      if (char === '{') braceCount++;
                      if (char === '}') braceCount--;
                  }
                  if (char === ',' && !inQuote && parenCount === 0 && bracketCount === 0 && braceCount === 0) {
                      params.push(currentParam.trim());
                      currentParam = '';
                      continue;
                  }
                  currentParam += char;
              }
              if (currentParam.trim()) {
                  params.push(currentParam.trim());
              }
              return params;
          },

          // --- 新增：文本净化辅助函数 ---
          _getDisplayText(aiResponse) {
            try {
              if (!aiResponse || typeof aiResponse !== 'string') return '';
              
              // 优先提取 <gametxt> 的内容
              const gameText = this._extractLastTagContent('gametxt', aiResponse);
              if (gameText !== null) {
                  return gameText;
              }

              // 备用方案：如果找不到 <gametxt>，则移除所有已知的非显示标签
              let cleanedText = aiResponse;
              const tagsToRemove = ['本世历程', '往世涟漪', 'UpdateVariable', '角色提取', 'thinking'];
              
              tagsToRemove.forEach(tag => {
                  // 移除 <tag>...</tag> 结构
                  const regexWithContent = new RegExp(`<${tag}>[\\s\\S]*?<\\/${tag}>`, 'gi');
                  cleanedText = cleanedText.replace(regexWithContent, '');
                  // 移除自闭合的 <tag/> 结构
                  const regexSelfClosing = new RegExp(`<${tag}\\s*\\/>`, 'gi');
                  cleanedText = cleanedText.replace(regexSelfClosing, '');
              });

              return cleanedText.trim();
            } catch (e) {
              console.error("Lỗi khi phân tích văn bản hiển thị:", e, "Đầu vào gốc:", aiResponse);
              return "[Phân tích tóm tắt thất bại]";
            }
          },

          // --- 新增：可重用的、健壮的标签提取函数 ---
          _extractLastTagContent(tagName, text, ignoreCase = false) {
              if (!text || typeof text !== 'string') return null;

              const endTag = `</${tagName}>`;
              let searchPool = text;
              let endTagPattern = endTag;

              if (ignoreCase) {
                  searchPool = text.toLowerCase();
                  endTagPattern = endTag.toLowerCase();
              }

              const lastEndIndex = searchPool.lastIndexOf(endTagPattern);

              if (lastEndIndex !== -1) {
                  const startTag = `<${tagName}>`;
                  let startTagPattern = startTag;
                  if (ignoreCase) {
                      startTagPattern = startTag.toLowerCase();
                  }
                  
                  const lastStartIndex = searchPool.lastIndexOf(startTagPattern, lastEndIndex);

                  if (lastStartIndex !== -1) {
                      const startIndex = lastStartIndex + startTag.length;
                      return text.substring(startIndex, lastEndIndex).trim();
                  }
              }
              return null;
          },

          // --- 新增：多存档管理功能 ---
          showSaveLoadManager() {
            this.openModal('save-load-modal');
            const container = document.getElementById('save-slots-container');
            if (!container) return;

            let saves;
            try {
                saves = this.getSavesFromStorage();
            } catch (e) {
                console.error("Phân tích toàn bộ tệp lưu trữ thất bại, có thể do lỗi định dạng JSON:", e);
                container.innerHTML = `
                    <div style="color: #ff6b6b; padding: 20px; text-align: center;">
                        <p>Lỗi: Tệp lưu trữ chính đã bị hỏng, không thể đọc.</p>
                        <p style="font-size: 12px; color: #8b7355; margin-top: 10px;">Bạn có thể thử "Làm mới bộ nhớ đệm" trong Trung tâm Mệnh lệnh để xóa tất cả dữ liệu cục bộ.</p>
                    </div>
                `;
                return;
            }

            let html = '';
            const totalSlots = 5; // 总共提供5个存档位

            for (let i = 1; i <= totalSlots; i++) {
              const slotId = `slot_${i}`;
              try {
                const saveData = saves[slotId];
                
                html += `
                  <div class="save-slot" data-slot-id="${slotId}">
                    <div class="save-slot-info">
                `;

                // **最终修复**: 智能判断存档结构，兼容新旧两种数据格式
                let statDataForRender = null;
                // **最终修复V2**: 增加更严格的类型检查，防止 mvu_data 为 null 或非对象时出错
                if (saveData && typeof saveData.mvu_data === 'object' && saveData.mvu_data !== null) {
                    if (saveData.mvu_data.stat_data) {
                        // 兼容旧结构: { mvu_data: { stat_data: {...} } }
                        statDataForRender = saveData.mvu_data.stat_data;
                    } else if (saveData.mvu_data['Cảnh Giới Hiện Tại']) {
                        // 兼容新结构: { mvu_data: {...} } (mvu_data本身就是stat_data)
                        statDataForRender = saveData.mvu_data;
                    }
                }

                if (statDataForRender) {
                  const date = new Date(saveData.timestamp).toLocaleString('vi-VN');
                  const jingjie = this.SafeGetValue(statDataForRender, 'Cảnh Giới Hiện Tại.0', 'Cảnh giới không rõ');
                  const jinian = this.SafeGetValue(statDataForRender, 'Niên Đại Thời Gian Hiện Tại.0', 'Niên kỷ không rõ');
                  const summary = this._getDisplayText(saveData.message_content);
                  const saveName = saveData.save_name || `Lưu trữ ${i}`;

                  html += `
                      <div class="slot-name">${saveName}</div>
                      <div class="slot-time">${date} - ${jingjie} - ${jinian}</div>
                      <div class="slot-summary">${summary ? summary.substring(0, 40) + '...' : 'Không có ghi chép chính văn'}</div>
                  `;
                } else if (saveData) {
                  // 存档存在，但数据结构不完整
                  html += `
                      <div class="slot-name">Lưu trữ ${i}</div>
                      <div class="slot-time" style="color: #ff6b6b; font-weight: bold;">Dữ liệu lưu trữ bị hỏng (thiếu dữ liệu chính)</div>
                  `;
                } else {
                  // 空存档位
                  html += `
                      <div class="slot-name">Lưu trữ ${i}</div>
                      <div class="slot-time" style="font-style: italic; color: #8b7355;">Ô lưu trữ trống</div>
                  `;
                }

                html += `
                    </div>
                    <div class="save-slot-actions">
                      <button class="interaction-btn btn-save-slot" style="padding: 8px 12px;">Lưu</button>
                      <button class="interaction-btn btn-load-slot" style="padding: 8px 12px;" ${!saveData ? 'disabled' : ''}>Tải</button>
                      <button class="interaction-btn btn-delete-slot" style="padding: 8px 12px; background: #8b0000;" ${!saveData ? 'disabled' : ''}>Xóa</button>
                    </div>
                  </div>
                `;
              } catch (e) {
                console.error(`Lỗi không xác định khi hiển thị ô lưu trữ ${i} (ID: ${slotId}):`, e);
                html += `
                  <div class="save-slot" data-slot-id="${slotId}">
                    <div class="save-slot-info">
                      <div class="slot-name">Lưu trữ ${i}</div>
                      <div class="slot-time" style="color: #ff6b6b; font-weight: bold;">Lỗi không xác định khi hiển thị</div>
                      <div class="slot-summary" style="font-size:10px; color: #8b7355;">${e.message}</div>
                    </div>
                    <div class="save-slot-actions">
                      <button class="interaction-btn btn-save-slot" style="padding: 8px 12px;">Ghi đè</button>
                      <button class="interaction-btn btn-load-slot" style="padding: 8px 12px;" disabled>Tải</button>
                      <button class="interaction-btn btn-delete-slot" style="padding: 8px 12px; background: #8b0000;">Xóa</button>
                    </div>
                  </div>
                `;
              }
            }
            container.innerHTML = html;
            this.bindSaveSlotListeners();
          },

          bindSaveSlotListeners() {
            const container = document.getElementById('save-slots-container');
            if (!container) {
              console.error('[Lưu trữ Quy Khư] Không tìm thấy phần tử chứa các ô lưu trữ');
              return;
            }

            // 使用克隆节点的方式来确保每次都绑定新的、干净的事件监听器
            const newContainer = container.cloneNode(true);
            container.parentNode.replaceChild(newContainer, container);

            console.log('[Lưu trữ Quy Khư] Gán trình lắng nghe sự kiện cho các nút lưu trữ');
            newContainer.addEventListener('click', (e) => {
              const target = e.target;
              const slotDiv = target.closest('.save-slot');
              if (!slotDiv) return;
              
              const slotId = slotDiv.dataset.slotId;
              console.log('[Lưu trữ Quy Khư] Nhấn nút lưu trữ, ô:', slotId, 'loại nút:', target.className);

              if (target.classList.contains('btn-save-slot')) {
                console.log('[Lưu trữ Quy Khư] Thực hiện thao tác lưu');
                this.saveGame(slotId);
              } else if (target.classList.contains('btn-load-slot')) {
                console.log('[Lưu trữ Quy Khư] Thực hiện thao tác tải');
                this.loadGame(slotId);
              } else if (target.classList.contains('btn-delete-slot')) {
                console.log('[Lưu trữ Quy Khư] Thực hiện thao tác xóa');
                this.deleteSave(slotId);
              }
            });
          },

          getSavesFromStorage() {
            try {
              const saves = localStorage.getItem('guixu_multi_save_data');
              return saves ? JSON.parse(saves) : {};
            } catch (e) {
              console.error("Lấy tệp lưu thất bại:", e);
              return {};
            }
          },

          async saveGame(slotId) {
            try {
              // 首先弹出输入框让用户命名存档
              const saveName = await this.promptForSaveName(slotId);
              if (!saveName) {
                this.showTemporaryMessage('Đã hủy lưu trữ');
                return;
              }

              const allSaves = this.getSavesFromStorage();
              const slotExists = allSaves[slotId];

              const performSave = async () => {
                try {
                  // 修复：优先使用缓存的mvu状态，如果没有再从消息获取
                  let currentMvuData = this.currentMvuState;
                  let currentMessageContent = '';
                  
                  if (!currentMvuData) {
                    console.log('[Lưu trữ Quy Khư] Trạng thái cache trống, thử lấy từ tin nhắn...');
                    const messages = await getChatMessages(getCurrentMessageId());
                    if (!messages || messages.length === 0) {
                      this.showTemporaryMessage('Lỗi: Không thể lấy dữ liệu tin nhắn hiện tại, không thể lưu.');
                      return;
                    }
                    currentMvuData = messages[0].data;
                    currentMessageContent = messages[0].message || '';
                  } else {
                    // 如果有缓存状态，也尝试获取当前消息内容
                    try {
                      const messages = await getChatMessages(getCurrentMessageId());
                      if (messages && messages.length > 0) {
                        currentMessageContent = messages[0].message || '';
                      }
                    } catch (e) {
                      console.warn('[Lưu trữ Quy Khư] Lấy nội dung tin nhắn thất bại, sử dụng nội dung trống:', e);
                    }
                  }
                  
                  if (!currentMvuData || !currentMvuData.stat_data) {
                    this.showTemporaryMessage('错误：MVU数据不完整，无法存档。请先进行一次游戏操作。');
                    return;
                  }
                  
                  console.log('[Lưu trữ Quy Khư] Bắt đầu lưu, kiểm tra dữ liệu đã qua');
                

                // --- 新逻辑：创建独立的世界书条目 ---
                const bookName = 'Quy Khư 2.5-UI';
                const index = this.unifiedIndex;
                const journeyKey = index > 1 ? `Hành Trình Kiếp Này(${index})` : 'Hành Trình Kiếp Này';
                const pastLivesKey = index > 1 ? `Sóng Nước Kiếp Xưa(${index})` : 'Sóng Nước Kiếp Xưa';
                
                // 生成独立世界书条目名称
                const saveJourneyEntryName = `${saveName}-Hành Trình Kiếp Này`;
                const savePastLivesEntryName = `${saveName}-Sóng Nước Kiếp Xưa`;
                
                let lorebookEntries = {
                  journey_entry_name: saveJourneyEntryName,
                  past_lives_entry_name: savePastLivesEntryName
                };

                try {
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
                  const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);
                  
                  // 创建独立的世界书条目
                  const entriesToCreate = [];
                  
                  // 修复：即使内容为空也创建条目，避免存档失败
                  if (journeyEntry) {
                    entriesToCreate.push({
                      comment: saveJourneyEntryName,
                      content: journeyEntry.content || '', // 允许空内容
                      keys: [saveJourneyEntryName],
                      enabled: false, // 默认禁用
                      position: 'before_character_definition',
                      order: 20
                    });
                    console.log(`[Lưu trữ Quy Khư] Chuẩn bị tạo mục Hành Trình Kiếp Này, độ dài nội dung: ${(journeyEntry.content || '').length}`);
                  } else {
                    // 如果找不到原始条目，创建一个空的
                    entriesToCreate.push({
                      comment: saveJourneyEntryName,
                      content: '# Hành Trình Kiếp Này\nTạm thời không có ghi chép',
                      keys: [saveJourneyEntryName],
                      enabled: false,
                      position: 'before_character_definition',
                      order: 20
                    });
                    console.log(`[Lưu trữ Quy Khư] Mục Hành Trình Kiếp Này gốc không tồn tại, tạo mục trống`);
                  }
                  
                  if (pastLivesEntry) {
                    entriesToCreate.push({
                      comment: savePastLivesEntryName,
                      content: pastLivesEntry.content || '', // 允许空内容
                      keys: [savePastLivesEntryName],
                      enabled: false, // 默认禁用
                      position: 'before_character_definition',
                      order: 19
                    });
                    console.log(`[Lưu trữ Quy Khư] Chuẩn bị tạo mục Sóng Nước Kiếp Xưa, độ dài nội dung: ${(pastLivesEntry.content || '').length}`);
                  } else {
                    // 如果找不到原始条目，创建一个空的
                    entriesToCreate.push({
                      comment: savePastLivesEntryName,
                      content: '# Sóng Nước Kiếp Xưa\nTạm thời không có ghi chép',
                      keys: [savePastLivesEntryName],
                      enabled: false,
                      position: 'before_character_definition',
                      order: 19
                    });
                    console.log(`[Lưu trữ Quy Khư] Mục Sóng Nước Kiếp Xưa gốc không tồn tại, tạo mục trống`);
                  }
                  
                  if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[Lưu trữ Quy Khư] Đã tạo ${entriesToCreate.length} mục Lorebook độc lập`);
                  }
                  
                } catch (e) {
                  console.error("Lỗi khi tạo mục Lorebook độc lập:", e);
                  this.showTemporaryMessage("Cảnh báo: Tạo mục Lorebook thất bại, nhưng dữ liệu chính vẫn sẽ được lưu.");
                }
                // --- 新逻辑结束 ---
                
                const saveDataPayload = {
                  timestamp: new Date().toISOString(),
                  save_name: saveName, // 新增：用户输入的存档名称
                  message_content: currentMessageContent,
                  lorebook_entries: lorebookEntries, // 修改：改为世界书条目名称
                  mvu_data: {
                    stat_data: currentMvuData.stat_data,
                    schema: currentMvuData.schema,
                    initialized_lorebooks: currentMvuData.initialized_lorebooks,
                    display_data: currentMvuData.display_data,
                    delta_data: currentMvuData.delta_data,
                  }
                };

                allSaves[slotId] = saveDataPayload;

                localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));
                this.showTemporaryMessage(`Tệp lưu "${saveName}" đã được lưu vào ô ${slotId.split('_')[1]}`);
                this.showSaveLoadManager(); // Refresh UI
                } catch (error) {
                  console.error('Lưu thất bại:', error);
                  this.showTemporaryMessage(`Lưu thất bại: ${error.message}`);
                }
              };

              if (slotExists) {
                this.showCustomConfirm(`Ô lưu trữ ${slotId.split('_')[1]} đã có dữ liệu, chắc chắn muốn ghi đè không?`, performSave);
              } else {
                await performSave();
              }
            } catch (error) {
              console.error('Lỗi trong quá trình lưu:', error);
              this.showTemporaryMessage(`Lưu thất bại: ${error.message}`);
            }
          },

          async loadGame(slotId) {
            const allSaves = this.getSavesFromStorage();
            const saveData = allSaves[slotId];
            
            if (!saveData) {
              this.showTemporaryMessage('Không tìm thấy tệp lưu.');
              return;
            }

            const saveName = saveData.save_name || `Lưu trữ ${slotId.split('_')[1]}`;
            this.showCustomConfirm(`Chắc chắn muốn tải tệp lưu "${saveName}" không? Tất cả tiến độ chưa lưu hiện tại sẽ bị ghi đè.`, async () => {
              try {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) {
                  this.showTemporaryMessage('Lỗi: Không thể lấy tin nhắn hiện tại, không thể tải.');
                  return;
                }
                
                const messageZero = messages[0];
                const loadedData = saveData.mvu_data;
                const loadedMessageContent = saveData.message_content || '';

                messageZero.data = loadedData;
                messageZero.message = loadedMessageContent;

                // --- 新逻辑：从独立世界书恢复到当前序号 ---
                if (saveData.lorebook_entries) {
                  const entries = saveData.lorebook_entries;
                  const bookName = 'Quy Khư 2.5-UI';
                  const currentIndex = this.unifiedIndex;
                  const currentJourneyKey = currentIndex > 1 ? `Hành Trình Kiếp Này(${currentIndex})` : 'Hành Trình Kiếp Này';
                  const currentPastLivesKey = currentIndex > 1 ? `Sóng Nước Kiếp Xưa(${currentIndex})` : 'Sóng Nước Kiếp Xưa';

                  try {
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    
                    // 查找存档的独立世界书条目
                    const saveJourneyEntry = allEntries.find(entry => entry.comment === entries.journey_entry_name);
                    const savePastLivesEntry = allEntries.find(entry => entry.comment === entries.past_lives_entry_name);
                    
                    // 查找当前序号的世界书条目
                    const currentJourneyEntry = allEntries.find(entry => entry.comment === currentJourneyKey);
                    const currentPastLivesEntry = allEntries.find(entry => entry.comment === currentPastLivesKey);
                    
                    const entriesToUpdate = [];
                    
                    // Overwrite Hành Trình Kiếp Này - Fix: Allow restoration of empty content
                    if (saveJourneyEntry) {
                      const contentToRestore = saveJourneyEntry.content || '';
                      if (currentJourneyEntry) {
                        // 更新现有条目
                        entriesToUpdate.push({
                          uid: currentJourneyEntry.uid,
                          content: contentToRestore
                        });
                        console.log(`[Tải Quy Khư] Cập nhật mục Hành Trình Kiếp Này, độ dài nội dung: ${contentToRestore.length}`);
                      } else {
                        // 创建新条目
                        await TavernHelper.createLorebookEntries(bookName, [{
                          comment: currentJourneyKey,
                          content: contentToRestore,
                          keys: [currentJourneyKey],
                          enabled: true,
                          position: 'before_character_definition',
                          order: 20
                        }]);
                        console.log(`[Tải Quy Khư] Tạo mục Hành Trình Kiếp Này, độ dài nội dung: ${contentToRestore.length}`);
                      }
                    }
                    
                    // Overwrite Sóng Nước Kiếp Xưa - Fix: Allow restoration of empty content
                    if (savePastLivesEntry) {
                      const contentToRestore = savePastLivesEntry.content || '';
                      if (currentPastLivesEntry) {
                        // 更新现有条目
                        entriesToUpdate.push({
                          uid: currentPastLivesEntry.uid,
                          content: contentToRestore
                        });
                        console.log(`[Tải Quy Khư] Cập nhật mục Sóng Nước Kiếp Xưa, độ dài nội dung: ${contentToRestore.length}`);
                      } else {
                        // 创建新条目
                        await TavernHelper.createLorebookEntries(bookName, [{
                          comment: currentPastLivesKey,
                          content: contentToRestore,
                          keys: [currentPastLivesKey],
                          enabled: true,
                          position: 'before_character_definition',
                          order: 19
                        }]);
                        console.log(`[Tải Quy Khư] Tạo mục Sóng Nước Kiếp Xưa, độ dài nội dung: ${contentToRestore.length}`);
                      }
                    }
                    
                    // 批量更新现有条目
                    if (entriesToUpdate.length > 0) {
                      await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    }
                    
                    console.log(`[Tải Quy Khư] Đã ghi đè dữ liệu Lorebook của tệp lưu "${saveName}" vào số thứ tự hiện tại ${currentIndex}`);
                    
                  } catch (e) {
                    console.error("Lỗi khi khôi phục dữ liệu Lorebook:", e);
                    this.showTemporaryMessage("Cảnh báo: Khôi phục dữ liệu Lorebook thất bại, nhưng dữ liệu chính đã được khôi phục.");
                  }
                }
                // --- 新逻辑结束 ---

                await TavernHelper.setChatMessages([messageZero], { refresh: 'all' });
                
                await this.loadAndDisplayCurrentScene(loadedMessageContent);
                await this.init();

                this.showTemporaryMessage(`Tải tệp lưu "${saveName}" thành công!`);
                this.closeAllModals();

              } catch (error) {
                console.error('Tải thất bại:', error);
                this.showTemporaryMessage(`Tải thất bại: ${error.message}`);
              }
            });
          },

          deleteSave(slotId) {
            this.showCustomConfirm(`Chắc chắn muốn xóa tệp lưu ${slotId.split('_')[1]} không? Thao tác này không thể hoàn tác.`, () => {
              try {
                const allSaves = this.getSavesFromStorage();
                if (allSaves[slotId]) {
                  delete allSaves[slotId];
                  localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));
                  this.showTemporaryMessage(`Tệp lưu ${slotId.split('_')[1]} đã bị xóa.`);
                  this.showSaveLoadManager(); // Refresh UI
                }
              } catch (error) {
                console.error('Xóa tệp lưu thất bại:', error);
                this.showTemporaryMessage(`Xóa tệp lưu thất bại: ${error.message}`);
              }
            });
          },

          clearAllSaves() {
            this.showCustomConfirm(`Bạn có chắc muốn xóa tất cả các tệp lưu không? Thao tác này sẽ xóa dữ liệu của cả 5 ô lưu trữ và không thể hoàn tác.`, () => {
              try {
                localStorage.removeItem('guixu_multi_save_data');
                this.showTemporaryMessage(`Tất cả các tệp lưu đã được xóa.`);
                this.showSaveLoadManager(); // 刷新UI
              } catch (error) {
                console.error('Xóa tất cả tệp lưu thất bại:', error);
                this.showTemporaryMessage(`Xóa tệp lưu thất bại: ${error.message}`);
              }
            });
          },

          // --- 新增：存档命名输入框 ---
          async promptForSaveName(slotId) {
            console.log('[Lưu trữ Quy Khư] Hiển thị hộp thoại đặt tên tệp lưu');
            return new Promise((resolve) => {
              try {
                // 创建模态框
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.style.zIndex = '2000'; // 确保在最顶层
                modal.innerHTML = `
                  <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                    <div class="modal-header">
                      <h2 class="modal-title">Đặt tên tệp lưu</h2>
                    </div>
                    <div class="modal-body" style="padding: 20px;">
                      <p style="margin-bottom: 15px; color: #c9aa71;">Vui lòng nhập tên cho ô lưu trữ ${slotId.split('_')[1]}:</p>
                      <input type="text" id="save-name-input" placeholder="Ví dụ: Đột phá Kim Đan kỳ"
                             style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                    color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 15px;">
                      <p style="font-size: 12px; color: #8b7355; margin-bottom: 20px;">
                        Sẽ tạo các mục Lorebook:<br>
                        • <span id="preview-journey">Tên-Hành Trình Kiếp Này</span><br>
                        • <span id="preview-past-lives">Tên-Sóng Nước Kiếp Xưa</span>
                      </p>
                      <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="save-name-cancel" class="interaction-btn">Hủy</button>
                        <button id="save-name-confirm" class="interaction-btn primary-btn">Xác nhận</button>
                      </div>
                    </div>
                  </div>
                `;

                const container = document.querySelector('.guixu-root-container');
                if (!container) {
                  console.error('[Lưu trữ Quy Khư] Không tìm thấy vùng chứa gốc');
                  resolve(null);
                  return;
                }
                container.appendChild(modal);

                const input = modal.querySelector('#save-name-input');
                const previewJourney = modal.querySelector('#preview-journey');
                const previewPastLives = modal.querySelector('#preview-past-lives');
                const confirmBtn = modal.querySelector('#save-name-confirm');
                const cancelBtn = modal.querySelector('#save-name-cancel');

                if (!input || !confirmBtn || !cancelBtn) {
                  console.error('[Lưu trữ Quy Khư] Tạo phần tử modal thất bại');
                  modal.remove();
                  resolve(null);
                  return;
                }

                // 实时更新预览
                input.addEventListener('input', () => {
                  const name = input.value.trim() || 'Tên';
                  if (previewJourney) previewJourney.textContent = `${name}-Hành Trình Kiếp Này`;
                  if (previewPastLives) previewPastLives.textContent = `${name}-Sóng Nước Kiếp Xưa`;
                });

                // 确认按钮
                confirmBtn.addEventListener('click', () => {
                  const saveName = input.value.trim();
                  if (!saveName) {
                    this.showTemporaryMessage('Vui lòng nhập tên tệp lưu');
                    return;
                  }
                  console.log('[Lưu trữ Quy Khư] Người dùng nhập tên tệp lưu:', saveName);
                  modal.remove();
                  resolve(saveName);
                });

                // Cancel button
                cancelBtn.addEventListener('click', () => {
                  console.log('[Lưu trữ Quy Khư] Người dùng hủy lưu trữ');
                  modal.remove();
                  resolve(null);
                });

                // 回车确认
                input.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                    confirmBtn.click();
                  }
                });

                // 自动聚焦
                setTimeout(() => {
                  try {
                    input.focus();
                  } catch (e) {
                    console.warn('[Lưu trữ Quy Khư] Tự động lấy nét thất bại:', e);
                  }
                }, 100);

              } catch (error) {
                console.error('[Lưu trữ Quy Khư] Lỗi khi tạo hộp thoại đặt tên tệp lưu:', error);
                resolve(null);
              }
            });
          },

        };
 
         // --- Entry Point ---
         // Tác phẩm của Lão Não/Lữ Trình Mộng Tinh, cấm đăng lại, cấm thương mại hóa, tất cả đều được chia sẻ miễn phí và mã nguồn mở
        eventOn(tavern_events.APP_READY, () => {
          GuixuManager.init();
        });

        // 事件监听已在 GuixuManager.init() 中处理，此处不再需要
      })();
    </script>
  </body>
</html>
